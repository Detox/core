// Generated by LiveScript 1.5.0
/**
 * @package   Detox core
 * @author    Nazar Mokrynskyi <nazar@mokrynskyi.com>
 * @copyright Copyright (c) 2017, Nazar Mokrynskyi
 * @license   MIT License, see license.txt
 */
(function(){
  var DHT_COMMAND_ROUTING, DHT_COMMAND_FORWARD_INTRODUCTION, DHT_COMMAND_GET_NODES_REQUEST, DHT_COMMAND_GET_NODES_RESPONSE, ROUTING_COMMAND_ANNOUNCE, ROUTING_COMMAND_FIND_INTRODUCTION_NODES_REQUEST, ROUTING_COMMAND_FIND_INTRODUCTION_NODES_RESPONSE, ROUTING_COMMAND_INITIALIZE_CONNECTION, ROUTING_COMMAND_INTRODUCTION, ROUTING_COMMAND_CONFIRM_CONNECTION, ROUTING_COMMAND_CONNECTED, ROUTING_COMMAND_DATA, ROUTING_COMMAND_PING, ID_LENGTH, SIGNATURE_LENGTH, HANDSHAKE_MESSAGE_LENGTH, MAC_LENGTH, APPLICATION_LENGTH, CONNECTION_TIMEOUT, ROUTING_PATH_SEGMENT_TIMEOUT, LAST_USED_TIMEOUT, ANNOUNCE_INTERVAL, STALE_AWARE_OF_NODE_TIMEOUT, AWARE_OF_NODES_LIMIT, GET_MORE_NODES_INTERVAL, CONNECTION_ERROR_OK, CONNECTION_ERROR_CANT_FIND_INTRODUCTION_NODES, CONNECTION_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES, CONNECTION_ERROR_NO_INTRODUCTION_NODES, CONNECTION_ERROR_CANT_CONNECT_TO_RENDEZVOUS_POINT, CONNECTION_ERROR_OUT_OF_INTRODUCTION_NODES, CONNECTION_PROGRESS_CONNECTED_TO_RENDEZVOUS_NODE, CONNECTION_PROGRESS_FOUND_INTRODUCTION_NODES, CONNECTION_PROGRESS_INTRODUCTION_SENT, ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONNECTED, ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONFIRMED, ANNOUNCEMENT_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES, randombytes;
  DHT_COMMAND_ROUTING = 0;
  DHT_COMMAND_FORWARD_INTRODUCTION = 1;
  DHT_COMMAND_GET_NODES_REQUEST = 2;
  DHT_COMMAND_GET_NODES_RESPONSE = 3;
  ROUTING_COMMAND_ANNOUNCE = 0;
  ROUTING_COMMAND_FIND_INTRODUCTION_NODES_REQUEST = 1;
  ROUTING_COMMAND_FIND_INTRODUCTION_NODES_RESPONSE = 2;
  ROUTING_COMMAND_INITIALIZE_CONNECTION = 3;
  ROUTING_COMMAND_INTRODUCTION = 4;
  ROUTING_COMMAND_CONFIRM_CONNECTION = 5;
  ROUTING_COMMAND_CONNECTED = 6;
  ROUTING_COMMAND_DATA = 7;
  ROUTING_COMMAND_PING = 8;
  ID_LENGTH = 32;
  SIGNATURE_LENGTH = 64;
  HANDSHAKE_MESSAGE_LENGTH = 48;
  MAC_LENGTH = 16;
  APPLICATION_LENGTH = 128;
  CONNECTION_TIMEOUT = 30;
  ROUTING_PATH_SEGMENT_TIMEOUT = 10;
  LAST_USED_TIMEOUT = 60;
  ANNOUNCE_INTERVAL = 30 * 60;
  STALE_AWARE_OF_NODE_TIMEOUT = 5 * 60;
  AWARE_OF_NODES_LIMIT = 1000;
  GET_MORE_NODES_INTERVAL = 30;
  CONNECTION_ERROR_OK = 0;
  CONNECTION_ERROR_CANT_FIND_INTRODUCTION_NODES = 1;
  CONNECTION_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES = 2;
  CONNECTION_ERROR_NO_INTRODUCTION_NODES = 3;
  CONNECTION_ERROR_CANT_CONNECT_TO_RENDEZVOUS_POINT = 4;
  CONNECTION_ERROR_OUT_OF_INTRODUCTION_NODES = 5;
  CONNECTION_PROGRESS_CONNECTED_TO_RENDEZVOUS_NODE = 0;
  CONNECTION_PROGRESS_FOUND_INTRODUCTION_NODES = 1;
  CONNECTION_PROGRESS_INTRODUCTION_SENT = 2;
  ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONNECTED = 0;
  ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONFIRMED = 1;
  ANNOUNCEMENT_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES = 2;
  if (typeof crypto !== 'undefined') {
    randombytes = function(size){
      var array;
      array = new Uint8Array(size);
      crypto.getRandomValues(array);
      return array;
    };
  } else {
    randombytes = require('crypto').randomBytes;
  }
  /**
   * @param {number} min
   * @param {number} max
   *
   * @return {number}
   */
  function random_int(min, max){
    var bytes, uint32_number;
    bytes = randombytes(4);
    uint32_number = new Uint32Array(bytes.buffer)[0];
    return Math.floor(uint32_number / Math.pow(2, 32) * (max - min + 1)) + min;
  }
  /**
   * @param {!Array} array Returned item will be removed from this array
   *
   * @return {*}
   */
  function pull_random_item_from_array(array){
    var length, index;
    length = array.length;
    if (length === 1) {
      return array.pop();
    } else {
      index = random_int(0, length - 1);
      return array.splice(index, 1)[0];
    }
  }
  /**
   * @param {!Uint8Array}	address
   * @param {!Uint8Array}	route_id
   *
   * @return {string}
   */
  function compute_source_id(address, route_id){
    return address.join(',') + route_id.join(',');
  }
  /**
   * @param {string}		string
   * @param {!Uint8Array}	array
   *
   * @return {boolean}
   */
  function is_string_equal_to_array(string, array){
    return string === array.join(',');
  }
  /**
   * @param {number}				code
   * @param {!Uint8Array}			target_id
   * @param {!Array<!Uint8Array>}	nodes
   *
   * @return {!Uint8Array}
   */
  function compose_find_introduction_nodes_response(code, target_id, nodes){
    var x$, result, i$, len$, i, node;
    x$ = result = new Uint8Array(1 + ID_LENGTH + nodes.length * ID_LENGTH);
    x$.set([code]);
    x$.set(target_id, 1);
    for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
      i = i$;
      node = nodes[i$];
      result.set(node, 1 + ID_LENGTH + i * ID_LENGTH);
    }
    return result;
  }
  /**
   * @param {!Uint8Array} data
   *
   * @return {!Array} [code, target_id, nodes]
   */
  function parse_find_introduction_nodes_response(data){
    var code, target_id, nodes, i$, to$, i;
    code = data[0];
    target_id = data.subarray(1, 1 + ID_LENGTH);
    nodes = [];
    data = data.subarray(1 + ID_LENGTH);
    for (i$ = 0, to$ = data.length / ID_LENGTH; i$ < to$; ++i$) {
      i = i$;
      nodes.push(data.subarray(i * ID_LENGTH, (i + 1) * ID_LENGTH));
    }
    return [code, target_id, nodes];
  }
  /**
   * @param {!Uint8Array} target_id
   * @param {!Uint8Array} introduction_node
   * @param {!Uint8Array} rendezvous_node
   * @param {!Uint8Array} rendezvous_token
   * @param {!Uint8Array} handshake_message
   * @param {!Uint8Array} application
   * @param {!Uint8Array} secret
   *
   * @return {!Uint8Array}
   */
  function compose_introduction_payload(target_id, introduction_node, rendezvous_node, rendezvous_token, handshake_message, application, secret){
    var x$;
    x$ = new Uint8Array(ID_LENGTH * 4 + HANDSHAKE_MESSAGE_LENGTH + APPLICATION_LENGTH + ID_LENGTH);
    x$.set(target_id);
    x$.set(introduction_node, ID_LENGTH);
    x$.set(rendezvous_node, ID_LENGTH * 2);
    x$.set(rendezvous_token, ID_LENGTH * 3);
    x$.set(handshake_message, ID_LENGTH * 4);
    x$.set(application, ID_LENGTH * 4 + HANDSHAKE_MESSAGE_LENGTH);
    x$.set(secret, ID_LENGTH * 4 + HANDSHAKE_MESSAGE_LENGTH + APPLICATION_LENGTH);
    return x$;
  }
  /**
   * @param {!Uint8Array} introduction_payload
   *
   * @return {!Array<Uint8Array>} [target_id, introduction_node, rendezvous_node, rendezvous_token, handshake_message, application, secret]
   */
  function parse_introduction_payload(introduction_payload){
    var target_id, introduction_node, rendezvous_node, rendezvous_token, handshake_message, application, secret;
    target_id = introduction_payload.subarray(0, ID_LENGTH);
    introduction_node = introduction_payload.subarray(ID_LENGTH, ID_LENGTH * 2);
    rendezvous_node = introduction_payload.subarray(ID_LENGTH * 2, ID_LENGTH * 3);
    rendezvous_token = introduction_payload.subarray(ID_LENGTH * 3, ID_LENGTH * 4);
    handshake_message = introduction_payload.subarray(ID_LENGTH * 4, ID_LENGTH * 4 + HANDSHAKE_MESSAGE_LENGTH);
    application = introduction_payload.subarray(ID_LENGTH * 4 + HANDSHAKE_MESSAGE_LENGTH, ID_LENGTH * 4 + HANDSHAKE_MESSAGE_LENGTH + APPLICATION_LENGTH);
    secret = introduction_payload.subarray(ID_LENGTH * 4 + HANDSHAKE_MESSAGE_LENGTH + APPLICATION_LENGTH, ID_LENGTH * 4 + HANDSHAKE_MESSAGE_LENGTH + APPLICATION_LENGTH + ID_LENGTH);
    return [target_id, introduction_node, rendezvous_node, rendezvous_token, handshake_message, application, secret];
  }
  /**
   * @param {!Uint8Array} rendezvous_token
   * @param {!Uint8Array} introduction_node
   * @param {!Uint8Array} target_id
   * @param {!Uint8Array} introduction_message
   *
   * @return {!Uint8Array}
   */
  function compose_initialize_connection_data(rendezvous_token, introduction_node, target_id, introduction_message){
    var x$;
    x$ = new Uint8Array(ID_LENGTH * 3 + introduction_message.length);
    x$.set(rendezvous_token);
    x$.set(introduction_node, ID_LENGTH);
    x$.set(target_id, ID_LENGTH * 2);
    x$.set(introduction_message, ID_LENGTH * 3);
    return x$;
  }
  /**
   * @param {!Uint8Array} message
   *
   * @return {!Array<Uint8Array>} [rendezvous_token, introduction_node, target_id, introduction_message]
   */
  function parse_initialize_connection_data(message){
    var rendezvous_token, introduction_node, target_id, introduction_message;
    rendezvous_token = message.subarray(0, ID_LENGTH);
    introduction_node = message.subarray(ID_LENGTH, ID_LENGTH * 2);
    target_id = message.subarray(ID_LENGTH * 2, ID_LENGTH * 3);
    introduction_message = message.subarray(ID_LENGTH * 3);
    return [rendezvous_token, introduction_node, target_id, introduction_message];
  }
  /**
   * @param {!Uint8Array} signature
   * @param {!Uint8Array} rendezvous_token
   * @param {!Uint8Array} handshake_message
   *
   * @return {!Uint8Array}
   */
  function compose_confirm_connection_data(signature, rendezvous_token, handshake_message){
    var x$;
    x$ = new Uint8Array(SIGNATURE_LENGTH + ID_LENGTH + HANDSHAKE_MESSAGE_LENGTH);
    x$.set(signature);
    x$.set(rendezvous_token, SIGNATURE_LENGTH);
    x$.set(handshake_message, SIGNATURE_LENGTH + ID_LENGTH);
    return x$;
  }
  /**
   * @param {!Uint8Array} message
   *
   * @return {!Array<Uint8Array>} [signature, rendezvous_token, handshake_message]
   */
  function parse_confirm_connection_data(message){
    var signature, rendezvous_token, handshake_message;
    signature = message.subarray(0, SIGNATURE_LENGTH);
    rendezvous_token = message.subarray(SIGNATURE_LENGTH, SIGNATURE_LENGTH + ID_LENGTH);
    handshake_message = message.subarray(SIGNATURE_LENGTH + ID_LENGTH);
    return [signature, rendezvous_token, handshake_message];
  }
  /**
   * @param {!Uint8Array} target_id
   * @param {!Uint8Array} introduction_message
   *
   * @return {!Uint8Array}
   */
  function compose_introduce_to_data(target_id, introduction_message){
    var x$;
    x$ = new Uint8Array(ID_LENGTH + introduction_message.length);
    x$.set(target_id);
    x$.set(introduction_message, ID_LENGTH);
    return x$;
  }
  /**
   * @param {!Uint8Array} message
   *
   * @return {!Array<Uint8Array>} [target_id, introduction_message]
   */
  function parse_introduce_to_data(message){
    var target_id, introduction_message;
    target_id = message.subarray(0, ID_LENGTH);
    introduction_message = message.subarray(ID_LENGTH);
    return [target_id, introduction_message];
  }
  function error_handler(error){
    if (error instanceof Error) {
      return console.error(error);
    }
  }
  function Wrapper(detoxCrypto, detoxTransport, fixedSizeMultiplexer, asyncEventer){
    /**
     * Generate random seed that can be used as keypair seed
     *
     * @return {!Uint8Array} 32 bytes
     */
    var x$, y$;
    function generate_seed(){
      return detoxCrypto['create_keypair']()['seed'];
    }
    /**
     * @constructor
     *
     * @param {!Uint8Array}		real_key_seed			Seed used to generate real long-term keypair
     * @param {!Uint8Array}		dht_key_seed			Seed used to generate temporary DHT keypair
     * @param {!Array<!Object>}	bootstrap_nodes
     * @param {!Array<!Object>}	ice_servers
     * @param {number}			packets_per_second		Each packet send in each direction has exactly the same size and packets are sent at fixed rate (>= 1)
     * @param {number}			bucket_size
     * @param {number}			max_pending_segments	How much routing segments can be in pending state per one address
     *
     * @return {!Core}
     *
     * @throws {Error}
     */
    function Core(real_key_seed, dht_key_seed, bootstrap_nodes, ice_servers, packets_per_second, bucket_size, max_pending_segments){
      var this$ = this;
      packets_per_second == null && (packets_per_second = 1);
      bucket_size == null && (bucket_size = 2);
      max_pending_segments == null && (max_pending_segments = 10);
      if (!(this instanceof Core)) {
        return new Core(real_key_seed, dht_key_seed, bootstrap_nodes, ice_servers, packets_per_second, bucket_size, max_pending_segments);
      }
      asyncEventer.call(this);
      this._real_keypair = detoxCrypto['create_keypair'](real_key_seed);
      this._dht_keypair = detoxCrypto['create_keypair'](dht_key_seed);
      this._max_data_size = detoxTransport['MAX_DATA_SIZE'];
      this._connected_nodes = new Map;
      this._aware_of_nodes = new Map;
      this._get_nodes_requested = new Set;
      this._routing_paths = new Map;
      this._id_to_routing_path = new Map;
      this._routing_path_to_id = new Map;
      this._used_tags = new Map;
      this._connections_timeouts = new Map;
      this._routes_timeouts = new Map;
      this._pending_connection = new Map;
      this._announced_to = new Map;
      this._announcements_from = new Map;
      this._forwarding_mapping = new Map;
      this._pending_pings = new Set;
      this._last_announcement = 0;
      this._encryptor_instances = new Map;
      this._multiplexers = new Map;
      this._demultiplexers = new Map;
      this._cleanup_interval = setInterval(function(){
        var unused_older_than;
        unused_older_than = +new Date - LAST_USED_TIMEOUT * 1000;
        this$._routes_timeouts.forEach(function(last_updated, source_id){
          var ref$, node_id, route_id;
          if (last_updated < unused_older_than) {
            if (this$._routing_paths.has(source_id)) {
              ref$ = this$._routing_paths.get(source_id), node_id = ref$[0], route_id = ref$[1];
              this$._unregister_routing_path(node_id, route_id);
            }
            this$._routes_timeouts['delete'](source_id);
          }
        });
        this$._connections_timeouts.forEach(function(arg$, node_id_string){
          var last_updated, node_id;
          last_updated = arg$[0], node_id = arg$[1];
          if (last_updated < unused_older_than) {
            this$._del_used_tag(node_id);
            this$._connections_timeouts['delete'](node_id_string);
          }
        });
      }, LAST_USED_TIMEOUT * 1000);
      this._keep_announce_routes_interval = setInterval(function(){
        var reAnnounce_if_older_than;
        this$._announced_to.forEach(function(introduction_node, introduction_node_string){
          var ref$, node_id, route_id, source_id;
          ref$ = this$._id_to_routing_path.get(introduction_node_string), node_id = ref$[0], route_id = ref$[1];
          if (this$._send_ping(node_id, route_id)) {
            source_id = compute_source_id(node_id, route_id);
            this$._pending_pings.add(source_id);
          }
        });
        if (this$._announced_to.size < this$._number_of_introduction_nodes && this$._last_announcement) {
          reAnnounce_if_older_than = +new Date - CONNECTION_TIMEOUT * 3;
          if (this$._last_announcement < reAnnounce_if_older_than) {
            this$._announce();
          }
        }
      }, LAST_USED_TIMEOUT / 2 * 1000);
      this._get_more_nodes_interval = setInterval(function(){
        if (this$._more_nodes_needed()) {
          this$._get_more_nodes();
        }
      }, GET_MORE_NODES_INTERVAL * 1000);
      this._sign = function(data){
        return detoxCrypto['sign'](data, this$._real_keypair['ed25519']['public'], this$._real_keypair['ed25519']['private']);
      };
      this._dht = detoxTransport['DHT'](this._dht_keypair['ed25519']['public'], this._dht_keypair['ed25519']['private'], bootstrap_nodes, ice_servers, packets_per_second, bucket_size)['on']('node_connected', function(node_id){
        this$._connected_nodes.set(node_id.join(','), node_id);
        if (this$._more_nodes_needed()) {
          this$._get_more_nodes_from(node_id);
        }
      })['on']('node_disconnected', function(node_id){
        var node_id_string;
        node_id_string = node_id.join(',');
        this$._connected_nodes['delete'](node_id_string);
        this$._get_nodes_requested['delete'](node_id_string);
      })['on']('data', function(node_id, command, data){
        var ref$, target_id, introduction_message, target_id_string, target_node_id, target_route_id, nodes, i$, len$, i, node, node_id_string, number_of_nodes, stale_aware_of_nodes, new_node_id, new_node_id_string, stale_node_to_remove;
        switch (command) {
        case DHT_COMMAND_ROUTING:
          this$._router['process_packet'](node_id, data);
          break;
        case DHT_COMMAND_FORWARD_INTRODUCTION:
          if (this$._bootstrap_node) {
            return;
          }
          ref$ = parse_introduce_to_data(data), target_id = ref$[0], introduction_message = ref$[1];
          target_id_string = target_id.join(',');
          if (!this$._announcements_from.has(target_id_string)) {
            return;
          }
          ref$ = this$._announcements_from.get(target_id_string), target_node_id = ref$[1], target_route_id = ref$[2];
          this$._router['send_data'](target_node_id, target_route_id, ROUTING_COMMAND_INTRODUCTION, introduction_message);
          break;
        case DHT_COMMAND_GET_NODES_REQUEST:
          nodes = this$._pick_random_connected_nodes(7) || [];
          nodes = nodes.concat(this$._pick_random_aware_of_nodes(10 - nodes.length) || []);
          data = new Uint8Array(nodes.length * ID_LENGTH);
          for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
            i = i$;
            node = nodes[i$];
            data.set(node, i * ID_LENGTH);
          }
          this$._send_to_dht_node(node_id, DHT_COMMAND_GET_NODES_RESPONSE, data);
          break;
        case DHT_COMMAND_GET_NODES_RESPONSE:
          node_id_string = node_id.join(',');
          if (!this$._get_nodes_requested.has(node_id_string)) {
            return;
          }
          this$._get_nodes_requested['delete'](node_id_string);
          if (!data.length || data.length % ID_LENGTH !== 0) {
            return;
          }
          number_of_nodes = data.length / ID_LENGTH;
          stale_aware_of_nodes = this$._get_stale_aware_of_nodes();
          for (i$ = 0; i$ < number_of_nodes; ++i$) {
            i = i$;
            new_node_id = data.subarray(i * ID_LENGTH, (i + 1) * ID_LENGTH);
            new_node_id_string = new_node_id.join(',');
            if (is_string_equal_to_array(new_node_id_string, this$._dht_keypair['ed25519']['public']) || this$._connected_nodes.has(new_node_id_string)) {
              continue;
            }
            if (this$._aware_of_nodes.has(new_node_id_string) || this$._aware_of_nodes.size < AWARE_OF_NODES_LIMIT) {
              this$._aware_of_nodes.set(new_node_id_string, [new_node_id, +new Date]);
            } else if (stale_aware_of_nodes.length) {
              stale_node_to_remove = pull_random_item_from_array(stale_aware_of_nodes);
              this$._aware_of_nodes['delete'](stale_node_to_remove);
              this$._aware_of_nodes.set(new_node_id_string, [new_node_id, +new Date]);
            } else {
              break;
            }
          }
        }
      })['on']('ready', function(){
        this$._dht['lookup'](randombytes(ID_LENGTH));
        this$._dht['lookup'](randombytes(ID_LENGTH));
        this$._dht['lookup'](randombytes(ID_LENGTH));
        this$['fire']('ready');
      });
      this._router = detoxTransport['Router'](this._dht_keypair['x25519']['private'], max_pending_segments)['on']('activity', function(node_id, route_id){
        var source_id;
        source_id = compute_source_id(node_id, route_id);
        if (!this$._routing_paths.has(source_id)) {
          this$._routing_paths.set(source_id, [node_id, route_id]);
        }
        this$._update_connection_timeout(node_id);
        this$._routes_timeouts.set(source_id, +new Date);
      })['on']('send', function(node_id, data){
        this$._send_to_dht_node(node_id, DHT_COMMAND_ROUTING, data);
      })['on']('data', function(node_id, route_id, command, data){
        var source_id, public_key, public_key_string, announce_interval, target_id, send_response, ref$, rendezvous_token, introduction_node, introduction_message, rendezvous_token_string, connection_timeout, signature, handshake_message, target_node_id, target_route_id, target_source_id, introduction_node_string, introduction_message_decrypted, introduction_payload, introduction_node_received, rendezvous_node, application, secret, target_id_string, error, encryptor_instance, demultiplexer, data_decrypted, data_with_header;
        source_id = compute_source_id(node_id, route_id);
        switch (command) {
        case ROUTING_COMMAND_ANNOUNCE:
          if (this$._bootstrap_node) {
            return;
          }
          public_key = this$._dht['verify_announcement_message'](data);
          if (!public_key) {
            return;
          }
          public_key_string = public_key.join(',');
          if (this$._announcements_from.has(public_key_string)) {
            clearInterval(this$._announcements_from.get(public_key_string)[3]);
          }
          announce_interval = setInterval(function(){
            if (!this$._routing_paths.has(source_id)) {
              return;
            }
            this$._dht['publish_announcement_message'](data);
          }, ANNOUNCE_INTERVAL * 1000);
          this$._announcements_from.set(public_key_string, [public_key, node_id, route_id, announce_interval]);
          this$._dht['publish_announcement_message'](data);
          break;
        case ROUTING_COMMAND_FIND_INTRODUCTION_NODES_REQUEST:
          if (this$._bootstrap_node) {
            return;
          }
          target_id = data;
          if (target_id.length !== ID_LENGTH) {
            return;
          }
          /**
           * @param {number}				code
           * @param {!Array<!Uint8Array>}	nodes
           */
          send_response = function(code, nodes){
            var data;
            data = compose_find_introduction_nodes_response(code, target_id, nodes);
            this$._router['send_data'](node_id, route_id, ROUTING_COMMAND_FIND_INTRODUCTION_NODES_RESPONSE, data);
          };
          this$._dht['find_introduction_nodes'](target_id, function(introduction_nodes){
            if (!introduction_nodes.length) {
              send_response(CONNECTION_ERROR_NO_INTRODUCTION_NODES, []);
            } else {
              send_response(CONNECTION_ERROR_OK, introduction_nodes);
            }
          }, function(){
            send_response(CONNECTION_ERROR_NO_INTRODUCTION_NODES, []);
          });
          break;
        case ROUTING_COMMAND_INITIALIZE_CONNECTION:
          if (this$._bootstrap_node) {
            return;
          }
          ref$ = parse_initialize_connection_data(data), rendezvous_token = ref$[0], introduction_node = ref$[1], target_id = ref$[2], introduction_message = ref$[3];
          rendezvous_token_string = rendezvous_token.join(',');
          if (this$._pending_connection.has(rendezvous_token_string)) {
            return;
          }
          connection_timeout = setTimeout(function(){
            this$._pending_connection['delete'](rendezvous_token_string);
          }, CONNECTION_TIMEOUT * 1000);
          this$._pending_connection.set(rendezvous_token_string, [node_id, route_id, target_id, connection_timeout]);
          this$._send_to_dht_node(introduction_node, DHT_COMMAND_FORWARD_INTRODUCTION, compose_introduce_to_data(target_id, introduction_message));
          break;
        case ROUTING_COMMAND_CONFIRM_CONNECTION:
          ref$ = parse_confirm_connection_data(data), signature = ref$[0], rendezvous_token = ref$[1], handshake_message = ref$[2];
          rendezvous_token_string = rendezvous_token.join(',');
          if (!this$._pending_connection.has(rendezvous_token_string)) {
            return;
          }
          ref$ = this$._pending_connection.get(rendezvous_token_string), target_node_id = ref$[0], target_route_id = ref$[1], target_id = ref$[2], connection_timeout = ref$[3];
          if (!detoxCrypto['verify'](signature, rendezvous_token, target_id)) {
            return;
          }
          clearTimeout(connection_timeout);
          this$._router['send_data'](target_node_id, target_route_id, ROUTING_COMMAND_CONNECTED, data);
          target_source_id = compute_source_id(target_node_id, target_route_id);
          this$._forwarding_mapping.set(source_id, [target_node_id, target_route_id]);
          this$._forwarding_mapping.set(target_source_id, [node_id, route_id]);
          break;
        case ROUTING_COMMAND_INTRODUCTION:
          if (!this$._routing_path_to_id.has(source_id)) {
            return;
          }
          introduction_node = this$._routing_path_to_id.get(source_id);
          introduction_node_string = introduction_node.join(',');
          if (!this$._announced_to.has(introduction_node_string)) {
            return;
          }
          try {
            introduction_message_decrypted = detoxCrypto['one_way_decrypt'](this$._real_keypair['x25519']['private'], data);
            signature = introduction_message_decrypted.subarray(0, SIGNATURE_LENGTH);
            introduction_payload = introduction_message_decrypted.subarray(SIGNATURE_LENGTH);
            ref$ = parse_introduction_payload(introduction_payload), target_id = ref$[0], introduction_node_received = ref$[1], rendezvous_node = ref$[2], rendezvous_token = ref$[3], handshake_message = ref$[4], application = ref$[5], secret = ref$[6];
            if (!is_string_equal_to_array(introduction_node_received.join(','), introduction_node) || !detoxCrypto['verify'](signature, introduction_payload, target_id)) {
              return;
            }
            target_id_string = target_id.join(',');
            if (this$._id_to_routing_path.has(target_id_string)) {
              return;
            }
            data = {
              'target_id': target_id,
              'secret': secret,
              'application': application,
              'number_of_intermediate_nodes': null
            };
            this$['fire']('introduction', data).then(function(){
              var number_of_intermediate_nodes, nodes, first_node;
              number_of_intermediate_nodes = data['number_of_intermediate_nodes'];
              if (!number_of_intermediate_nodes) {
                throw new Error('Direct connections are not yet supported');
                return;
              }
              nodes = this$._pick_nodes_for_routing_path(number_of_intermediate_nodes, [rendezvous_node]);
              if (!nodes) {
                return;
              }
              nodes.push(rendezvous_node);
              first_node = nodes[0];
              this$._router['construct_routing_path'](nodes).then(function(route_id){
                var encryptor_instance, response_handshake_message, signature;
                encryptor_instance = detoxCrypto['Encryptor'](false, this$._real_keypair['x25519']['private']);
                encryptor_instance['put_handshake_message'](handshake_message);
                response_handshake_message = encryptor_instance['get_handshake_message']();
                this$._encryptor_instances.set(target_id_string, encryptor_instance);
                this$._register_routing_path(target_id, first_node, route_id);
                signature = this$._sign(rendezvous_token);
                this$._send_to_routing_node(target_id, ROUTING_COMMAND_CONFIRM_CONNECTION, compose_confirm_connection_data(signature, rendezvous_token, response_handshake_message));
              })['catch'](function(error){
                error_handler(error);
              });
            })['catch'](function(error){
              error_handler(error);
            });
          } catch (e$) {
            error = e$;
            error_handler(error);
          }
          break;
        case ROUTING_COMMAND_DATA:
          if (this$._forwarding_mapping.has(source_id)) {
            ref$ = this$._forwarding_mapping.get(source_id), target_node_id = ref$[0], target_route_id = ref$[1];
            this$._router['send_data'](target_node_id, target_route_id, ROUTING_COMMAND_DATA, data);
          } else if (this$._routing_path_to_id.has(source_id)) {
            target_id = this$._routing_path_to_id.get(source_id);
            target_id_string = target_id.join(',');
            encryptor_instance = this$._encryptor_instances.get(target_id_string);
            if (!encryptor_instance) {
              return;
            }
            demultiplexer = this$._demultiplexers.get(target_id_string);
            if (!demultiplexer) {
              return;
            }
            data_decrypted = encryptor_instance['decrypt'](data);
            demultiplexer['feed'](data_decrypted);
            if (demultiplexer['have_more_data']()) {
              data_with_header = demultiplexer['get_data']();
              command = data_with_header[0];
              this$['fire']('data', target_id, command, data_with_header.subarray(1));
            }
          }
          break;
        case ROUTING_COMMAND_PING:
          if (this$._routing_path_to_id.has(source_id)) {
            target_id = this$._routing_path_to_id.get(source_id);
            target_id_string = target_id.join(',');
            if (this$._pending_pings.has(source_id)) {
              this$._pending_pings['delete'](source_id);
              return;
            }
          }
          this$._send_ping(node_id, route_id);
        }
      });
      this._max_packet_data_size = this._router['get_max_packet_data_size']() - MAC_LENGTH;
    }
    x$ = Core;
    x$['CONNECTION_ERROR_CANT_FIND_INTRODUCTION_NODES'] = CONNECTION_ERROR_CANT_FIND_INTRODUCTION_NODES;
    x$['CONNECTION_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES'] = CONNECTION_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES;
    x$['CONNECTION_ERROR_NO_INTRODUCTION_NODES'] = CONNECTION_ERROR_NO_INTRODUCTION_NODES;
    x$['CONNECTION_ERROR_CANT_CONNECT_TO_RENDEZVOUS_POINT'] = CONNECTION_ERROR_CANT_CONNECT_TO_RENDEZVOUS_POINT;
    x$['CONNECTION_ERROR_OUT_OF_INTRODUCTION_NODES'] = CONNECTION_ERROR_OUT_OF_INTRODUCTION_NODES;
    x$['CONNECTION_PROGRESS_CONNECTED_TO_RENDEZVOUS_NODE'] = CONNECTION_PROGRESS_CONNECTED_TO_RENDEZVOUS_NODE;
    x$['CONNECTION_PROGRESS_FOUND_INTRODUCTION_NODES'] = CONNECTION_PROGRESS_FOUND_INTRODUCTION_NODES;
    x$['CONNECTION_PROGRESS_INTRODUCTION_SENT'] = CONNECTION_PROGRESS_INTRODUCTION_SENT;
    x$['ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONNECTED'] = ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONNECTED;
    x$['ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONFIRMED'] = ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONFIRMED;
    x$['ANNOUNCEMENT_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES'] = ANNOUNCEMENT_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES;
    Core.prototype = Object.create(asyncEventer.prototype);
    y$ = Core.prototype;
    /**
     * Start WebSocket server listening on specified ip:port, so that current node will be capable of acting as bootstrap node for other users
     *
     * @param {string}	ip
     * @param {number}	port
     */
    y$['start_bootstrap_node'] = function(ip, port){
      this._dht['start_bootstrap_node'](ip, port);
      this._bootstrap_node = true;
    };
    /**
     * Get an array of bootstrap nodes obtained during DHT operation in the same format as `bootstrap_nodes` argument in constructor
     *
     * @return {!Array<!Object>} Each element is an object with keys `host`, `port` and `node_id`
     */
    y$['get_bootstrap_nodes'] = function(){
      return this._dht['get_bootstrap_nodes']();
    };
    /**
     * @param {number} number_of_introduction_nodes
     * @param {number} number_of_intermediate_nodes	How many hops should be made until introduction node (not including it)
     */
    y$['announce'] = function(number_of_introduction_nodes, number_of_intermediate_nodes){
      this._number_of_introduction_nodes = number_of_introduction_nodes;
      this._number_of_intermediate_nodes = number_of_intermediate_nodes;
      this._announce();
    };
    y$._announce = function(){
      var old_introduction_nodes, number_of_introduction_nodes, number_of_intermediate_nodes, introduction_nodes, introductions_pending, introduction_nodes_confirmed, i$, len$, this$ = this;
      old_introduction_nodes = [];
      this._announced_to.forEach(function(introduction_node){
        old_introduction_nodes.push(introduction_node);
      });
      number_of_introduction_nodes = this._number_of_introduction_nodes - old_introduction_nodes.length;
      if (!number_of_introduction_nodes) {
        return;
      }
      number_of_intermediate_nodes = this._number_of_intermediate_nodes;
      this._last_announcement = +new Date;
      introduction_nodes = this._pick_random_aware_of_nodes(number_of_introduction_nodes, old_introduction_nodes);
      if (!introduction_nodes) {
        this._last_announcement = 1;
        this['fire']('announcement_failed', ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONNECTED);
        return;
      }
      introductions_pending = number_of_introduction_nodes;
      introduction_nodes_confirmed = [];
      function announced(introduction_node){
        var announcement_message, i$, len$, introduction_node_string;
        if (introduction_node) {
          introduction_nodes_confirmed.push(introduction_node);
        }
        --introductions_pending;
        if (introductions_pending) {
          return;
        }
        if (!introduction_nodes_confirmed.length) {
          this$._last_announcement = 1;
          this$['fire']('announcement_failed', ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONFIRMED);
          return;
        }
        introduction_nodes_confirmed = introduction_nodes_confirmed.concat(old_introduction_nodes);
        announcement_message = this$._dht['generate_announcement_message'](this$._real_keypair['ed25519']['public'], this$._real_keypair['ed25519']['private'], introduction_nodes_confirmed);
        for (i$ = 0, len$ = introduction_nodes_confirmed.length; i$ < len$; ++i$) {
          introduction_node = introduction_nodes_confirmed[i$];
          this$._send_to_routing_node(introduction_node, ROUTING_COMMAND_ANNOUNCE, announcement_message);
          introduction_node_string = introduction_node.join(',');
          this$._announced_to.set(introduction_node_string, introduction_node);
        }
        this$['fire']('announced');
      }
      for (i$ = 0, len$ = introduction_nodes.length; i$ < len$; ++i$) {
        (fn$.call(this, introduction_nodes[i$]));
      }
      function fn$(introduction_node){
        var nodes, first_node, this$ = this;
        nodes = this._pick_nodes_for_routing_path(number_of_intermediate_nodes, introduction_nodes.concat(old_introduction_nodes));
        if (!nodes) {
          this['fire']('announcement_failed', ANNOUNCEMENT_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES);
          return;
        }
        nodes.push(introduction_node);
        first_node = nodes[0];
        this._router['construct_routing_path'](nodes).then(function(route_id){
          this$._register_routing_path(introduction_node, first_node, route_id);
          announced(introduction_node);
        })['catch'](function(error){
          error_handler(error);
          announced();
        });
      }
    };
    /**
     * @param {!Uint8Array}	target_id						Real Ed25519 pubic key of interested node
     * @param {!Uint8Array}	application						Up to 128 bytes
     * @param {!Uint8Array}	secret							Up to 32 bytes
     * @param {number}		number_of_intermediate_nodes	How many hops should be made until rendezvous node (including it)
     */
    y$['connect_to'] = function(target_id, application, secret, number_of_intermediate_nodes){
      var target_id_string, nodes, first_node, rendezvous_node, this$ = this;
      if (!number_of_intermediate_nodes) {
        throw new Error('Direct connections are not yet supported');
        return;
      }
      target_id_string = target_id.join(',');
      if (this._id_to_routing_path.has(target_id_string)) {
        return;
      }
      nodes = this._pick_nodes_for_routing_path(number_of_intermediate_nodes);
      if (!nodes) {
        this['fire']('connection_failed', target_id, CONNECTION_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES);
        return;
      }
      first_node = nodes[0];
      rendezvous_node = nodes[nodes.length - 1];
      this._router['construct_routing_path'](nodes).then(function(route_id){
        var first_node_string, route_id_string, find_introduction_nodes_timeout;
        this$['fire']('connection_progress', target_id, CONNECTION_PROGRESS_CONNECTED_TO_RENDEZVOUS_NODE);
        first_node_string = first_node.join(',');
        route_id_string = route_id.join(',');
        function found_introduction_nodes(node_id, route_id, command, data){
          var ref$, code, target_id, introduction_nodes;
          if (!is_string_equal_to_array(first_node_string, node_id) || !is_string_equal_to_array(route_id_string, route_id) || command !== ROUTING_COMMAND_FIND_INTRODUCTION_NODES_RESPONSE) {
            return;
          }
          ref$ = parse_find_introduction_nodes_response(data), code = ref$[0], target_id = ref$[1], introduction_nodes = ref$[2];
          if (!is_string_equal_to_array(target_id_string, target_id)) {
            return;
          }
          clearTimeout(find_introduction_nodes_timeout);
          if (code !== CONNECTION_ERROR_OK) {
            this$['fire']('connection_failed', target_id, code);
            return;
          }
          this$['fire']('connection_progress', target_id, CONNECTION_PROGRESS_FOUND_INTRODUCTION_NODES);
          function try_to_introduce(){
            var introduction_node, rendezvous_token, x25519_public_key, encryptor_instance, handshake_message, introduction_payload, signature, x$, introduction_message, introduction_message_encrypted, path_confirmation_timeout;
            if (!introduction_nodes.length) {
              this$['fire']('connection_failed', target_id, CONNECTION_ERROR_OUT_OF_INTRODUCTION_NODES);
              return;
            }
            introduction_node = pull_random_item_from_array(introduction_nodes);
            rendezvous_token = randombytes(ID_LENGTH);
            x25519_public_key = detoxCrypto['convert_public_key'](target_id);
            encryptor_instance = detoxCrypto['Encryptor'](true, x25519_public_key);
            handshake_message = encryptor_instance['get_handshake_message']();
            introduction_payload = compose_introduction_payload(this$._real_keypair['ed25519']['public'], introduction_node, rendezvous_node, rendezvous_token, handshake_message, application, secret);
            signature = this$._sign(introduction_payload);
            x$ = introduction_message = new Uint8Array(introduction_payload.length + signature.length);
            x$.set(signature);
            x$.set(introduction_payload, SIGNATURE_LENGTH);
            introduction_message_encrypted = detoxCrypto['one_way_encrypt'](x25519_public_key, introduction_message);
            function path_confirmation(node_id, route_id, command, data){
              var ref$, signature, rendezvous_token_received, handshake_message_received;
              if (!is_string_equal_to_array(first_node_string, node_id) || !is_string_equal_to_array(route_id_string, route_id) || command !== ROUTING_COMMAND_CONNECTED) {
                return;
              }
              ref$ = parse_confirm_connection_data(data), signature = ref$[0], rendezvous_token_received = ref$[1], handshake_message_received = ref$[2];
              if (rendezvous_token_received.join(',') !== rendezvous_token.join(',') || !detoxCrypto['verify'](signature, rendezvous_token, target_id)) {
                return;
              }
              encryptor_instance['put_handshake_message'](handshake_message_received);
              this$._encryptor_instances.set(target_id_string, encryptor_instance);
              clearTimeout(path_confirmation_timeout);
              this$._router['off']('data', path_confirmation);
              this$._register_routing_path(target_id, node_id, route_id);
            }
            this$._router['on']('data', path_confirmation);
            this$._router['send_data'](first_node, route_id, ROUTING_COMMAND_INITIALIZE_CONNECTION, compose_initialize_connection_data(rendezvous_token, introduction_node, target_id, introduction_message_encrypted));
            this$['fire']('connection_progress', target_id, CONNECTION_PROGRESS_INTRODUCTION_SENT);
            path_confirmation_timeout = setTimeout(function(){
              this$._router['off']('data', path_confirmation);
              encryptor_instance['destroy']();
              try_to_introduce();
            }, CONNECTION_TIMEOUT * 1000);
          }
          try_to_introduce();
        }
        this$._router['on']('data', found_introduction_nodes);
        this$._router['send_data'](first_node, route_id, ROUTING_COMMAND_FIND_INTRODUCTION_NODES_REQUEST, target_id);
        find_introduction_nodes_timeout = setTimeout(function(){
          this$._router['off']('data', found_introduction_nodes);
          this$['fire']('connection_failed', target_id, CONNECTION_ERROR_CANT_FIND_INTRODUCTION_NODES);
        }, CONNECTION_TIMEOUT * 1000);
      })['catch'](function(error){
        error_handler(error);
        this$['fire']('connection_failed', target_id, CONNECTION_ERROR_CANT_CONNECT_TO_RENDEZVOUS_POINT);
      });
    };
    y$['get_max_data_size'] = function(){
      return this._max_data_size;
    };
    /**
     * @param {!Uint8Array}	target_id	Should be connected already
     * @param {number}		command		Command from range `0..255`
     * @param {!Uint8Array}	data		Up to 65 KiB (limit defined in `@detox/transport`)
     */
    y$['send_to'] = function(target_id, command, data){
      var target_id_string, encryptor_instance, multiplexer, x$, data_with_header, data_block, data_block_encrypted;
      target_id_string = target_id.join(',');
      encryptor_instance = this._encryptor_instances.get(target_id_string);
      if (!encryptor_instance || data.length > this._max_data_size) {
        return;
      }
      multiplexer = this._multiplexers.get(target_id_string);
      if (!multiplexer) {
        return;
      }
      x$ = data_with_header = new Uint8Array(data.length + 1);
      x$.set([command]);
      x$.set(data, 1);
      multiplexer['feed'](data_with_header);
      while (multiplexer['have_more_blocks']()) {
        data_block = multiplexer['get_block']();
        data_block_encrypted = encryptor_instance['encrypt'](data_block);
        this._send_to_routing_node(target_id, ROUTING_COMMAND_DATA, data_block_encrypted);
      }
    };
    y$['destroy'] = function(){
      var this$ = this;
      clearInterval(this._cleanup_interval);
      clearInterval(this._keep_announce_routes_interval);
      clearInterval(this._get_more_nodes_interval);
      this._routing_paths.forEach(function(arg$){
        var node_id, route_id;
        node_id = arg$[0], route_id = arg$[1];
        this$._unregister_routing_path(node_id, route_id);
      });
      this._pending_connection.forEach(function(arg$){
        var connection_timeout;
        connection_timeout = arg$[3];
        clearTimeout(connection_timeout);
      });
      this._dht['destroy']();
      this._router['destroy']();
    };
    /**
     * @return {boolean}
     */
    y$._more_nodes_needed = function(){
      return this._aware_of_nodes.size < AWARE_OF_NODES_LIMIT || this._get_stale_aware_of_nodes(true).length;
    };
    /**
     * @param {boolean} early_exit Will return single node if present, used to check if stale nodes are present at all
     * @return {!Array<string>}
     */
    y$._get_stale_aware_of_nodes = function(early_exit){
      var stale_aware_of_nodes, stale_older_than, i$, ref$, len$, ref1$, node_id, date;
      early_exit == null && (early_exit = false);
      stale_aware_of_nodes = [];
      stale_older_than = +new Date - STALE_AWARE_OF_NODE_TIMEOUT * 1000;
      for (i$ = 0, len$ = (ref$ = Array.from(this._aware_of_nodes.values())).length; i$ < len$; ++i$) {
        ref1$ = ref$[i$], node_id = ref1$[0], date = ref1$[1];
        if (date < stale_older_than) {
          stale_aware_of_nodes.push(node_id.join(','));
          if (early_exit) {
            break;
          }
        }
      }
      return stale_aware_of_nodes;
    };
    /**
     * Request more nodes to be aware of from some of the nodes already connected to
     */
    y$._get_more_nodes = function(){
      var nodes, i$, len$, node_id;
      nodes = this._pick_random_connected_nodes(5);
      if (!nodes) {
        return;
      }
      for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
        node_id = nodes[i$];
        this._get_more_nodes_from(node_id);
      }
    };
    /**
     * @param {!Uint8Array}
     */
    y$._get_more_nodes_from = function(node_id){
      this._get_nodes_requested.add(node_id.join(','));
      this._send_to_dht_node(node_id, DHT_COMMAND_GET_NODES_REQUEST, new Uint8Array(0));
    };
    /**
     * Get some random nodes suitable for constructing routing path through them or for acting as introduction nodes
     *
     * @param {number}				number_of_nodes
     * @param {Array<Uint8Array>}	exclude_nodes
     *
     * @return {Array<Uint8Array>} `null` if there was not enough nodes
     */
    y$._pick_nodes_for_routing_path = function(number_of_nodes, exclude_nodes){
      var connected_node, intermediate_nodes;
      exclude_nodes == null && (exclude_nodes = null);
      connected_node = this._pick_random_connected_nodes(1, exclude_nodes);
      if (!connected_node) {
        return null;
      }
      intermediate_nodes = this._pick_random_aware_of_nodes(number_of_nodes - 1, exclude_nodes);
      if (!intermediate_nodes) {
        return null;
      }
      return connected_node.concat(intermediate_nodes);
    };
    /**
     * Get some random nodes from already connected nodes
     *
     * @param {number}				up_to_number_of_nodes
     * @param {!Array<Uint8Array>}	exclude_nodes
     *
     * @return {Array<Uint8Array>} `null` if there is no nodes to return
     */
    y$._pick_random_connected_nodes = function(up_to_number_of_nodes, exclude_nodes){
      var connected_nodes, i$, ref$, len$, bootstrap_node, i, results$ = [];
      up_to_number_of_nodes == null && (up_to_number_of_nodes = 1);
      exclude_nodes == null && (exclude_nodes = []);
      if (!this._connected_nodes.size) {
        this._dht['lookup'](randombytes(ID_LENGTH));
        return null;
      }
      connected_nodes = Array.from(this._connected_nodes.values());
      for (i$ = 0, len$ = (ref$ = this['get_bootstrap_nodes']()).length; i$ < len$; ++i$) {
        bootstrap_node = ref$[i$];
        exclude_nodes.push(bootstrap_node['node_id']);
      }
      connected_nodes = connected_nodes.filter(function(node){
        return !in$(node, exclude_nodes);
      });
      if (!connected_nodes.length) {
        return;
      }
      for (i$ = 0; i$ < up_to_number_of_nodes; ++i$) {
        i = i$;
        if (connected_nodes.length) {
          results$.push(pull_random_item_from_array(connected_nodes));
        }
      }
      return results$;
    };
    /**
     * Get some random nodes from those that current node is aware of
     *
     * @param {number}				number_of_nodes
     * @param {Array<Uint8Array>}	exclude_nodes
     *
     * @return {Array<Uint8Array>} `null` if there was not enough nodes
     */
    y$._pick_random_aware_of_nodes = function(number_of_nodes, exclude_nodes){
      var aware_of_nodes, i$, i, results$ = [];
      if (this._aware_of_nodes.size < number_of_nodes) {
        return null;
      }
      aware_of_nodes = Array.from(this._aware_of_nodes.values());
      if (exclude_nodes) {
        aware_of_nodes = aware_of_nodes.filter(function(node){
          return !in$(node, exclude_nodes);
        });
      }
      if (aware_of_nodes.length < number_of_nodes) {
        return null;
      }
      for (i$ = 0; i$ < number_of_nodes; ++i$) {
        i = i$;
        results$.push(pull_random_item_from_array(aware_of_nodes)[0]);
      }
      return results$;
    };
    /**
     * @param {!Uint8Array} target_id	Last node in routing path, responder
     * @param {!Uint8Array} node_id		First node in routing path, used for routing path identification
     * @param {!Uint8Array} route_id	ID of the route on `node_id`
     */
    y$._register_routing_path = function(target_id, node_id, route_id){
      var source_id, target_id_string;
      source_id = compute_source_id(node_id, route_id);
      target_id_string = target_id.join(',');
      if (this._routing_path_to_id.has(source_id)) {
        return;
      }
      this._id_to_routing_path.set(target_id_string, [node_id, route_id]);
      this._routing_path_to_id.set(source_id, target_id);
      this._multiplexers.set(target_id_string, fixedSizeMultiplexer['Multiplexer'](this._max_data_size, this._max_packet_data_size));
      this._demultiplexers.set(target_id_string, fixedSizeMultiplexer['Demultiplexer'](this._max_data_size, this._max_packet_data_size));
      this['fire']('connected', target_id);
    };
    /**
     * @param {!Uint8Array} node_id		First node in routing path, used for routing path identification
     * @param {!Uint8Array} route_id	ID of the route on `node_id`
     */
    y$._unregister_routing_path = function(node_id, route_id){
      var source_id, target_id, target_id_string, encryptor_instance, this$ = this;
      source_id = compute_source_id(node_id, route_id);
      if (!this._routing_paths.has(source_id)) {
        return;
      }
      this._routing_paths['delete'](source_id);
      this._router['destroy_routing_path'](node_id, route_id);
      this._routing_path_to_id['delete'](source_id);
      this._pending_pings['delete'](source_id);
      this._announcements_from.forEach(function(arg$, target_id_string_local){
        var node_id, route_id, announce_interval, source_id_local;
        node_id = arg$[1], route_id = arg$[2], announce_interval = arg$[3];
        source_id_local = compute_source_id(node_id, route_id);
        if (source_id !== source_id_local) {
          return;
        }
        clearInterval(announce_interval);
        this$._announcements_from['delete'](target_id_string_local);
      });
      target_id = this._routing_path_to_id.get(source_id);
      if (!target_id) {
        return;
      }
      target_id_string = target_id.join(',');
      this._id_to_routing_path['delete'](target_id_string);
      this._announced_to['delete'](target_id_string);
      encryptor_instance = this._encryptor_instances.get(target_id_string);
      if (encryptor_instance) {
        encryptor_instance['destroy']();
        this._encryptor_instances['delete'](target_id_string);
      }
      this._multiplexers['delete'](target_id_string);
      this._demultiplexers['delete'](target_id_string);
      this['fire']('disconnected', target_id);
    };
    /**
     * @param {!Uint8Array}	node_id
     * @param {number}		command	0..245
     * @param {!Uint8Array}	data
     */
    y$._send_to_dht_node = function(node_id, command, data){
      var node_id_string, connected_timeout, this$ = this;
      node_id_string = node_id.join(',');
      if (this._connected_nodes.has(node_id_string)) {
        this._update_connection_timeout(node_id);
        this._dht['send_data'](node_id, command, data);
        return;
      }
      function connected(node_id){
        if (!is_string_equal_to_array(node_id_string, node_id)) {
          return;
        }
        clearTimeout(connected_timeout);
        this$._dht['off']('node_connected', connected);
        this$._update_connection_timeout(node_id);
        this$._dht['send_data'](node_id, command, data);
      }
      this._dht['on']('node_connected', connected);
      connected_timeout = setTimeout(function(){
        this$._dht['off']('node_connected', connected);
      }, ROUTING_PATH_SEGMENT_TIMEOUT * 1000);
      this._dht['lookup'](node_id);
    };
    /**
     * @param {!Uint8Array}	target_id
     * @param {number}		command		0..245
     * @param {!Uint8Array}	data
     */
    y$._send_to_routing_node = function(target_id, command, data){
      var target_id_string, ref$, node_id, route_id;
      target_id_string = target_id.join(',');
      if (!this._id_to_routing_path.has(target_id_string)) {
        return;
      }
      ref$ = this._id_to_routing_path.get(target_id_string), node_id = ref$[0], route_id = ref$[1];
      this._router['send_data'](node_id, route_id, command, data);
    };
    /**
     * @param {!Uint8Array} node_id
     * @param {!Uint8Array} route_id
     *
     * @return {boolean} `true` if ping was sent (not necessary delivered)
     */
    y$._send_ping = function(node_id, route_id){
      var source_id;
      source_id = compute_source_id(node_id, route_id);
      if (this._pending_pings.has(source_id) || !this._routing_paths.has(source_id)) {
        return false;
      }
      this._router['send_data'](node_id, route_id, ROUTING_COMMAND_PING, new Uint8Array(0));
      return true;
    };
    /**
     * @param {!Uint8Array} node_id
     */
    y$._update_connection_timeout = function(node_id){
      var node_id_string;
      node_id_string = node_id.join(',');
      if (!this._connections_timeouts.has(node_id_string)) {
        this._add_used_tag(node_id);
      }
      this._connections_timeouts.set(node_id_string, [+new Date, node_id]);
    };
    /**
     * @param {!Uint8Array} node_id
     */
    y$._add_used_tag = function(node_id){
      var node_id_string, value;
      node_id_string = node_id.join(',');
      value = 0;
      if (this._used_tags.has(node_id_string)) {
        value = this._used_tags.get(node_id_string);
      }
      ++value;
      this._used_tags.set(node_id_string, value);
      if (value === 1) {
        this._dht['add_used_tag'](node_id);
      }
    };
    /**
     * @param {!Uint8Array} node_id
     */
    y$._del_used_tag = function(node_id){
      var node_id_string, value;
      node_id_string = node_id.join(',');
      if (!this._used_tags.has(node_id_string)) {
        return;
      }
      value = this._used_tags.get(node_id_string);
      --value;
      if (!value) {
        this._used_tags['delete'](node_id_string);
        this._dht['del_used_tag'](node_id);
      } else {
        this._used_tags.set(node_id_string, value);
      }
    };
    Object.defineProperty(Core.prototype, 'constructor', {
      enumerable: false,
      value: Core
    });
    return {
      'ready': function(callback){
        var wait_for;
        wait_for = 2;
        function ready(){
          --wait_for;
          if (!wait_for) {
            callback();
          }
        }
        detoxCrypto['ready'](ready);
        detoxTransport['ready'](ready);
      },
      'generate_seed': generate_seed,
      'Core': Core
    };
  }
  if (typeof define === 'function' && define['amd']) {
    define(['@detox/crypto', '@detox/transport', 'fixed-size-multiplexer', 'async-eventer'], Wrapper);
  } else if (typeof exports === 'object') {
    module.exports = Wrapper(require('@detox/crypto'), require('@detox/transport'), require('fixed-size-multiplexer'), require('async-eventer'));
  } else {
    this['detox_core'] = Wrapper(this['detox_crypto'], this['detox_transport'], this['fixed_size_multiplexer'], this['async_eventer']);
  }
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);
