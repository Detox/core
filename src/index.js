// Generated by LiveScript 1.5.0
/**
 * @package Detox core
 * @author  Nazar Mokrynskyi <nazar@mokrynskyi.com>
 * @license 0BSD
 */
(function(){
  /*
   * Implements version 0.4.1 of the specification
   */
  var DHT_COMMANDS_OFFSET, ROUTING_COMMANDS, UNCOMPRESSED_COMMANDS_OFFSET, UNCOMPRESSED_CORE_COMMANDS_OFFSET, COMPRESSED_CORE_COMMAND_SIGNAL, UNCOMPRESSED_CORE_COMMAND_FORWARD_INTRODUCTION, UNCOMPRESSED_CORE_COMMAND_GET_NODES_REQUEST, UNCOMPRESSED_CORE_COMMAND_GET_NODES_RESPONSE, UNCOMPRESSED_CORE_COMMAND_BOOTSTRAP_NODE, ROUTING_COMMAND_ANNOUNCE, ROUTING_COMMAND_FIND_INTRODUCTION_NODES_REQUEST, ROUTING_COMMAND_FIND_INTRODUCTION_NODES_RESPONSE, ROUTING_COMMAND_INITIALIZE_CONNECTION, ROUTING_COMMAND_INTRODUCTION, ROUTING_COMMAND_CONFIRM_CONNECTION, ROUTING_COMMAND_CONNECTED, ROUTING_COMMAND_DATA, ROUTING_COMMAND_PING, PUBLIC_KEY_LENGTH, SIGNATURE_LENGTH, HANDSHAKE_MESSAGE_LENGTH, MAC_LENGTH, APPLICATION_LENGTH, DEFAULT_TIMEOUTS, CONNECTION_OK, CONNECTION_ERROR_NO_INTRODUCTION_NODES, CONNECTION_ERROR_CANT_FIND_INTRODUCTION_NODES, CONNECTION_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES, CONNECTION_ERROR_CANT_CONNECT_TO_RENDEZVOUS_NODE, CONNECTION_ERROR_OUT_OF_INTRODUCTION_NODES, CONNECTION_PROGRESS_CONNECTED_TO_RENDEZVOUS_NODE, CONNECTION_PROGRESS_FOUND_INTRODUCTION_NODES, CONNECTION_PROGRESS_INTRODUCTION_SENT, ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONNECTED, ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONFIRMED, ANNOUNCEMENT_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES;
  DHT_COMMANDS_OFFSET = 10;
  ROUTING_COMMANDS = 20;
  UNCOMPRESSED_COMMANDS_OFFSET = ROUTING_COMMANDS;
  UNCOMPRESSED_CORE_COMMANDS_OFFSET = 21;
  COMPRESSED_CORE_COMMAND_SIGNAL = 0;
  UNCOMPRESSED_CORE_COMMAND_FORWARD_INTRODUCTION = 0;
  UNCOMPRESSED_CORE_COMMAND_GET_NODES_REQUEST = 1;
  UNCOMPRESSED_CORE_COMMAND_GET_NODES_RESPONSE = 2;
  UNCOMPRESSED_CORE_COMMAND_BOOTSTRAP_NODE = 3;
  ROUTING_COMMAND_ANNOUNCE = 0;
  ROUTING_COMMAND_FIND_INTRODUCTION_NODES_REQUEST = 1;
  ROUTING_COMMAND_FIND_INTRODUCTION_NODES_RESPONSE = 2;
  ROUTING_COMMAND_INITIALIZE_CONNECTION = 3;
  ROUTING_COMMAND_INTRODUCTION = 4;
  ROUTING_COMMAND_CONFIRM_CONNECTION = 5;
  ROUTING_COMMAND_CONNECTED = 6;
  ROUTING_COMMAND_DATA = 7;
  ROUTING_COMMAND_PING = 8;
  PUBLIC_KEY_LENGTH = 32;
  SIGNATURE_LENGTH = 64;
  HANDSHAKE_MESSAGE_LENGTH = 48;
  MAC_LENGTH = 16;
  APPLICATION_LENGTH = 64;
  DEFAULT_TIMEOUTS = {
    'CONNECTION_TIMEOUT': 10,
    'LAST_USED_TIMEOUT': 60,
    'ANNOUNCE_INTERVAL': 5 * 60,
    'STALE_AWARE_OF_NODE_TIMEOUT': 5 * 60,
    'GET_MORE_AWARE_OF_NODES_INTERVAL': 30,
    'RANDOM_LOOKUPS_INTERVAL': 60,
    'ROUTING_PATH_SEGMENT_TIMEOUT': 10
  };
  CONNECTION_OK = 0;
  CONNECTION_ERROR_NO_INTRODUCTION_NODES = 1;
  CONNECTION_ERROR_CANT_FIND_INTRODUCTION_NODES = 2;
  CONNECTION_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES = 3;
  CONNECTION_ERROR_CANT_CONNECT_TO_RENDEZVOUS_NODE = 4;
  CONNECTION_ERROR_OUT_OF_INTRODUCTION_NODES = 5;
  CONNECTION_PROGRESS_CONNECTED_TO_RENDEZVOUS_NODE = 0;
  CONNECTION_PROGRESS_FOUND_INTRODUCTION_NODES = 1;
  CONNECTION_PROGRESS_INTRODUCTION_SENT = 2;
  ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONNECTED = 0;
  ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONFIRMED = 1;
  ANNOUNCEMENT_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES = 2;
  /**
   * @param {!Uint8Array} signal
   * @param {!Uint8Array} signature
   *
   * @return {!Uint8Array}
   */
  function compose_bootstrap_response(signal, signature){
    var x$;
    x$ = new Uint8Array(signal.length + SIGNATURE_LENGTH);
    x$.set(signal);
    x$.set(signature, signal.length);
    return x$;
  }
  /**
   * @param {!Uint8Array} data
   *
   * @return {!Array<!Uint8Array>} [signal, signature]
   */
  function parse_bootstrap_response(data){
    var signal, signature;
    signal = data.subarray(0, data.length - SIGNATURE_LENGTH);
    signature = data.subarray(data.length - SIGNATURE_LENGTH);
    return [signal, signature];
  }
  /**
   * @param {!Uint8Array} source_id
   * @param {!Uint8Array} target_id
   * @param {!Uint8Array} sdp
   * @param {!Uint8Array} signature
   *
   * @return {!Uint8Array}
   */
  function compose_signal(source_id, target_id, sdp, signature){
    var x$;
    x$ = new Uint8Array(PUBLIC_KEY_LENGTH * 2 + sdp.length + SIGNATURE_LENGTH);
    x$.set(source_id);
    x$.set(target_id, PUBLIC_KEY_LENGTH);
    x$.set(sdp, PUBLIC_KEY_LENGTH * 2);
    x$.set(signature, PUBLIC_KEY_LENGTH * 2 + sdp.length);
    return x$;
  }
  /**
   * @param {!Uint8Array} data
   *
   * @return {!Array<!Uint8Array>} [source_id, target_id, sdp, signature]
   */
  function parse_signal(data){
    var source_id, target_id, sdp, signature;
    source_id = data.subarray(0, PUBLIC_KEY_LENGTH);
    target_id = data.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH * 2);
    sdp = data.subarray(PUBLIC_KEY_LENGTH * 2, data.length - SIGNATURE_LENGTH);
    signature = data.subarray(data.length - SIGNATURE_LENGTH);
    return [source_id, target_id, sdp, signature];
  }
  /**
   * @param {number}				code
   * @param {!Uint8Array}			target_id
   * @param {!Array<!Uint8Array>}	nodes
   *
   * @return {!Uint8Array}
   */
  function compose_find_introduction_nodes_response(code, target_id, nodes){
    var x$, result, i$, len$, i, node;
    x$ = result = new Uint8Array(1 + PUBLIC_KEY_LENGTH + nodes.length * PUBLIC_KEY_LENGTH);
    x$.set([code]);
    x$.set(target_id, 1);
    for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
      i = i$;
      node = nodes[i$];
      result.set(node, 1 + PUBLIC_KEY_LENGTH + i * PUBLIC_KEY_LENGTH);
    }
    return result;
  }
  /**
   * @param {!Uint8Array} data
   *
   * @return {!Array} [code, target_id, nodes]
   */
  function parse_find_introduction_nodes_response(data){
    var code, target_id, nodes, i$, to$, i;
    code = data[0];
    target_id = data.subarray(1, 1 + PUBLIC_KEY_LENGTH);
    nodes = [];
    data = data.subarray(1 + PUBLIC_KEY_LENGTH);
    for (i$ = 0, to$ = data.length / PUBLIC_KEY_LENGTH; i$ < to$; ++i$) {
      i = i$;
      nodes.push(data.subarray(i * PUBLIC_KEY_LENGTH, (i + 1) * PUBLIC_KEY_LENGTH));
    }
    return [code, target_id, nodes];
  }
  /**
   * @param {!Uint8Array} target_id
   * @param {!Uint8Array} rendezvous_node
   * @param {!Uint8Array} rendezvous_token
   * @param {!Uint8Array} handshake_message
   * @param {!Uint8Array} application
   * @param {!Uint8Array} secret
   *
   * @return {!Uint8Array}
   */
  function compose_introduction_payload(target_id, rendezvous_node, rendezvous_token, handshake_message, application, secret){
    var x$;
    x$ = new Uint8Array(PUBLIC_KEY_LENGTH * 3 + HANDSHAKE_MESSAGE_LENGTH + APPLICATION_LENGTH + PUBLIC_KEY_LENGTH);
    x$.set(target_id);
    x$.set(rendezvous_node, PUBLIC_KEY_LENGTH);
    x$.set(rendezvous_token, PUBLIC_KEY_LENGTH * 2);
    x$.set(handshake_message, PUBLIC_KEY_LENGTH * 3);
    x$.set(application, PUBLIC_KEY_LENGTH * 3 + HANDSHAKE_MESSAGE_LENGTH);
    x$.set(secret, PUBLIC_KEY_LENGTH * 3 + HANDSHAKE_MESSAGE_LENGTH + APPLICATION_LENGTH);
    return x$;
  }
  /**
   * @param {!Uint8Array} introduction_payload
   *
   * @return {!Array<!Uint8Array>} [target_id, rendezvous_node, rendezvous_token, handshake_message, application, secret]
   */
  function parse_introduction_payload(introduction_payload){
    var target_id, rendezvous_node, rendezvous_token, handshake_message, application, secret;
    target_id = introduction_payload.subarray(0, PUBLIC_KEY_LENGTH);
    rendezvous_node = introduction_payload.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH * 2);
    rendezvous_token = introduction_payload.subarray(PUBLIC_KEY_LENGTH * 2, PUBLIC_KEY_LENGTH * 3);
    handshake_message = introduction_payload.subarray(PUBLIC_KEY_LENGTH * 3, PUBLIC_KEY_LENGTH * 3 + HANDSHAKE_MESSAGE_LENGTH);
    application = introduction_payload.subarray(PUBLIC_KEY_LENGTH * 3 + HANDSHAKE_MESSAGE_LENGTH, PUBLIC_KEY_LENGTH * 3 + HANDSHAKE_MESSAGE_LENGTH + APPLICATION_LENGTH);
    secret = introduction_payload.subarray(PUBLIC_KEY_LENGTH * 3 + HANDSHAKE_MESSAGE_LENGTH + APPLICATION_LENGTH, PUBLIC_KEY_LENGTH * 3 + HANDSHAKE_MESSAGE_LENGTH + APPLICATION_LENGTH + PUBLIC_KEY_LENGTH);
    return [target_id, rendezvous_node, rendezvous_token, handshake_message, application, secret];
  }
  /**
   * @param {!Uint8Array} rendezvous_token
   * @param {!Uint8Array} introduction_node
   * @param {!Uint8Array} target_id
   * @param {!Uint8Array} introduction_message
   *
   * @return {!Uint8Array}
   */
  function compose_initialize_connection_data(rendezvous_token, introduction_node, target_id, introduction_message){
    var x$;
    x$ = new Uint8Array(PUBLIC_KEY_LENGTH * 3 + introduction_message.length);
    x$.set(rendezvous_token);
    x$.set(introduction_node, PUBLIC_KEY_LENGTH);
    x$.set(target_id, PUBLIC_KEY_LENGTH * 2);
    x$.set(introduction_message, PUBLIC_KEY_LENGTH * 3);
    return x$;
  }
  /**
   * @param {!Uint8Array} message
   *
   * @return {!Array<!Uint8Array>} [rendezvous_token, introduction_node, target_id, introduction_message]
   */
  function parse_initialize_connection_data(message){
    var rendezvous_token, introduction_node, target_id, introduction_message;
    rendezvous_token = message.subarray(0, PUBLIC_KEY_LENGTH);
    introduction_node = message.subarray(PUBLIC_KEY_LENGTH, PUBLIC_KEY_LENGTH * 2);
    target_id = message.subarray(PUBLIC_KEY_LENGTH * 2, PUBLIC_KEY_LENGTH * 3);
    introduction_message = message.subarray(PUBLIC_KEY_LENGTH * 3);
    return [rendezvous_token, introduction_node, target_id, introduction_message];
  }
  /**
   * @param {!Uint8Array} signature
   * @param {!Uint8Array} rendezvous_token
   * @param {!Uint8Array} handshake_message
   *
   * @return {!Uint8Array}
   */
  function compose_confirm_connection_data(signature, rendezvous_token, handshake_message){
    var x$;
    x$ = new Uint8Array(SIGNATURE_LENGTH + PUBLIC_KEY_LENGTH + HANDSHAKE_MESSAGE_LENGTH);
    x$.set(signature);
    x$.set(rendezvous_token, SIGNATURE_LENGTH);
    x$.set(handshake_message, SIGNATURE_LENGTH + PUBLIC_KEY_LENGTH);
    return x$;
  }
  /**
   * @param {!Uint8Array} message
   *
   * @return {!Array<!Uint8Array>} [signature, rendezvous_token, handshake_message]
   */
  function parse_confirm_connection_data(message){
    var signature, rendezvous_token, handshake_message;
    signature = message.subarray(0, SIGNATURE_LENGTH);
    rendezvous_token = message.subarray(SIGNATURE_LENGTH, SIGNATURE_LENGTH + PUBLIC_KEY_LENGTH);
    handshake_message = message.subarray(SIGNATURE_LENGTH + PUBLIC_KEY_LENGTH);
    return [signature, rendezvous_token, handshake_message];
  }
  /**
   * @param {!Uint8Array} target_id
   * @param {!Uint8Array} introduction_message
   *
   * @return {!Uint8Array}
   */
  function compose_introduce_to_data(target_id, introduction_message){
    var x$;
    x$ = new Uint8Array(PUBLIC_KEY_LENGTH + introduction_message.length);
    x$.set(target_id);
    x$.set(introduction_message, PUBLIC_KEY_LENGTH);
    return x$;
  }
  /**
   * @param {!Uint8Array} message
   *
   * @return {!Array<!Uint8Array>} [target_id, introduction_message]
   */
  function parse_introduce_to_data(message){
    var target_id, introduction_message;
    target_id = message.subarray(0, PUBLIC_KEY_LENGTH);
    introduction_message = message.subarray(PUBLIC_KEY_LENGTH);
    return [target_id, introduction_message];
  }
  /**
   * @param {!Function=} fetch
   */
  function Wrapper(detoxCrypto, detoxDht, detoxRouting, detoxTransport, detoxUtils, fixedSizeMultiplexer, asyncEventer, fetch){
    var hex2array, array2hex, string2array, array2string, random_bytes, random_int, pull_random_item_from_array, are_arrays_equal, concat_arrays, timeoutSet, intervalSet, error_handler, ArrayMap, ArraySet, sample, empty_array, null_id;
    fetch == null && (fetch = window['fetch']);
    hex2array = detoxUtils['hex2array'];
    array2hex = detoxUtils['array2hex'];
    string2array = detoxUtils['string2array'];
    array2string = detoxUtils['array2string'];
    random_bytes = detoxUtils['random_bytes'];
    random_int = detoxUtils['random_int'];
    pull_random_item_from_array = detoxUtils['pull_random_item_from_array'];
    are_arrays_equal = detoxUtils['are_arrays_equal'];
    concat_arrays = detoxUtils['concat_arrays'];
    timeoutSet = detoxUtils['timeoutSet'];
    intervalSet = detoxUtils['intervalSet'];
    error_handler = detoxUtils['error_handler'];
    ArrayMap = detoxUtils['ArrayMap'];
    ArraySet = detoxUtils['ArraySet'];
    sample = detoxUtils['sample'];
    empty_array = new Uint8Array(0);
    null_id = new Uint8Array(PUBLIC_KEY_LENGTH);
    /**
     * @param {Uint8Array} seed
     *
     * @return {!Object}
     */
    function create_keypair(seed){
      return detoxCrypto['create_keypair'](seed);
    }
    /**
     * @return {!Uint8Array}
     */
    function fake_node_id(){
      return create_keypair(null)['ed25519']['public'];
    }
    /**
     * @constructor
     *
     * @param {!Array<string>}	bootstrap_nodes		Array of strings in format `node_id:address:port`
     * @param {!Array<!Object>}	ice_servers
     * @param {number}			packets_per_second	Each packet send in each direction has exactly the same size and packets are sent at fixed rate (>= 1)
     * @param {number}			bucket_size
     * @param {Object=}			options				More options that are less frequently used
     *
     * @return {!Core}
     *
     * @throws {Error}
     */
    function Core(bootstrap_nodes, ice_servers, packets_per_second, bucket_size, options){
      var this$ = this;
      packets_per_second == null && (packets_per_second = 1);
      bucket_size == null && (bucket_size = 2);
      options == null && (options = {});
      if (!(this instanceof Core)) {
        return new Core(bootstrap_nodes, ice_servers, packets_per_second, bucket_size, options);
      }
      asyncEventer.call(this);
      this._options = Object.assign({
        'dht_keypair_seed': null,
        'state_history_size': 1000,
        'values_cache_size': 1000,
        'fraction_of_nodes_from_same_peer': 0.2,
        'lookup_number': Math.max(bucket_size, 5),
        'max_pending_segments': 10,
        'aware_of_nodes_limit': 1000,
        'min_number_of_peers_for_ready': bucket_size,
        'connected_nodes_limit': 50
      }, options, {
        'timeouts': Object.assign({}, DEFAULT_TIMEOUTS, options['timeouts'] || {})
      });
      this._real_keypairs = ArrayMap();
      this._dht_keypair = create_keypair(this._options['dht_key_seed']);
      this._dht_public_key = this._dht_keypair['ed25519']['public'];
      this._dht_private_key = this._dht_keypair['ed25519']['private'];
      this._max_data_size = detoxTransport['MAX_DATA_SIZE'];
      this._max_compressed_data_size = detoxTransport['MAX_COMPRESSED_DATA_SIZE'];
      this._bootstrap_nodes = new Set(bootstrap_nodes);
      this._bootstrap_nodes_ids = ArraySet();
      this._used_first_nodes = ArraySet();
      this._connections_in_progress = ArrayMap();
      this._connected_nodes = ArraySet();
      this._peers = ArraySet();
      this._waiting_for_signal = ArrayMap();
      this._aware_of_nodes = ArrayMap();
      this._get_nodes_requested = ArraySet();
      this._routing_paths = ArrayMap();
      this._id_to_routing_path = ArrayMap();
      this._routing_path_to_id = ArrayMap();
      this._connections_timeouts = ArrayMap();
      this._routes_timeouts = ArrayMap();
      this._pending_connections = ArrayMap();
      this._announcements_from = ArrayMap();
      this._forwarding_mapping = ArrayMap();
      this._pending_pings = ArraySet();
      this._encryptor_instances = ArrayMap();
      this._multiplexers = ArrayMap();
      this._demultiplexers = ArrayMap();
      this._pending_sending = ArrayMap();
      this._application_connections = ArraySet();
      this._cleanup_interval = intervalSet(this._options['timeouts']['LAST_USED_TIMEOUT'], function(){
        var unused_older_than, super_stale_older_than;
        unused_older_than = +new Date - this$._options['timeouts']['LAST_USED_TIMEOUT'] * 1000;
        this$._routes_timeouts.forEach(function(last_updated, source_id){
          var ref$, node_id, route_id;
          if (last_updated < unused_older_than) {
            if (this$._routing_paths.has(source_id)) {
              ref$ = this$._routing_paths.get(source_id), node_id = ref$[0], route_id = ref$[1];
              this$._unregister_routing_path(node_id, route_id);
            }
            this$._routes_timeouts['delete'](source_id);
          }
        });
        this$._connections_timeouts.forEach(function(last_updated, node_id){
          if (last_updated < unused_older_than) {
            this$._connections_timeouts['delete'](node_id);
            this$._transport['destroy_connection'](node_id);
          }
        });
        super_stale_older_than = +new Date - this$._options['timeouts']['STALE_AWARE_OF_NODE_TIMEOUT'] * 2 * 1000;
        this$._aware_of_nodes.forEach(function(date, node_id){
          if (date < super_stale_older_than) {
            this$._aware_of_nodes['delete'](node_id);
          }
        });
      });
      this._keep_announce_routes_interval = intervalSet(this._options['timeouts']['LAST_USED_TIMEOUT'] / 5 * 4, function(){
        this$._real_keypairs.forEach(function(arg$, real_public_key){
          var real_keypair, number_of_introduction_nodes, number_of_intermediate_nodes, announced_to, last_announcement, reannounce_if_older_than;
          real_keypair = arg$[0], number_of_introduction_nodes = arg$[1], number_of_intermediate_nodes = arg$[2], announced_to = arg$[3], last_announcement = arg$[4];
          if (announced_to.size < number_of_introduction_nodes && last_announcement) {
            reannounce_if_older_than = +new Date - this$._options['timeouts']['CONNECTION_TIMEOUT'] * 3;
            if (last_announcement < reannounce_if_older_than) {
              this$._announce(real_public_key);
            }
          }
          announced_to.forEach(function(introduction_node){
            var full_introduction_node_id, ref$, node_id, route_id, source_id;
            full_introduction_node_id = concat_arrays(real_public_key, introduction_node);
            ref$ = this$._id_to_routing_path.get(full_introduction_node_id), node_id = ref$[0], route_id = ref$[1];
            if (this$._send_ping(node_id, route_id)) {
              source_id = concat_arrays(node_id, route_id);
              this$._pending_pings.add(source_id);
            }
          });
        });
      });
      this._get_more_nodes_interval = intervalSet(this._options['timeouts']['GET_MORE_AWARE_OF_NODES_INTERVAL'], function(){
        if (this$._more_aware_of_nodes_needed()) {
          this$._get_more_aware_of_nodes();
        }
      });
      this._transport = detoxTransport['Transport'](this._dht_public_key, ice_servers, packets_per_second, UNCOMPRESSED_COMMANDS_OFFSET, this._options['timeouts']['CONNECTION_TIMEOUT'])['on']('connected', function(peer_id){
        var candidates_for_removal, nodes_used_in_forwarding, random_connected_node;
        this$._dht['add_peer'](peer_id);
        this$._connected_nodes.add(peer_id);
        this$._aware_of_nodes['delete'](peer_id);
        this$['fire']('aware_of_nodes_count', this$._aware_of_nodes.size);
        this$['fire']('connected_nodes_count', this$._connected_nodes.size);
        if (this$._bootstrap_node) {
          this$._send_uncompressed_core_command(peer_id, UNCOMPRESSED_CORE_COMMAND_BOOTSTRAP_NODE, string2array(this$._bootstrap_node));
        }
        if (this$._connected_nodes.size > this$._options['connected_nodes_limit']) {
          candidates_for_removal = [];
          nodes_used_in_forwarding = ArraySet();
          this$._forwarding_mapping.forEach(function(arg$){
            var node_id;
            node_id = arg$[0];
            nodes_used_in_forwarding.add(node_id);
          });
          this$._connected_nodes.forEach(function(node_id){
            if (!(are_arrays_equal(peer_id, node_id) || this$._used_first_nodes.has(node_id) || nodes_used_in_forwarding.has(node_id) || this$._peers.has(node_id))) {
              candidates_for_removal.push(node_id);
            }
          });
          if (candidates_for_removal.length) {
            random_connected_node = pull_random_item_from_array(candidates_for_removal);
            this$._transport['destroy_connection'](random_connected_node);
          }
        }
      })['on']('disconnected', function(peer_id){
        this$._dht['del_peer'](peer_id);
        this$._connected_nodes['delete'](peer_id);
        this$._peers['delete'](peer_id);
        this$['fire']('connected_nodes_count', this$._connected_nodes.size);
        this$._get_nodes_requested['delete'](peer_id);
      })['on']('data', function(peer_id, command, command_data){
        this$._update_connection_timeout(peer_id, false);
        if (command >= UNCOMPRESSED_CORE_COMMANDS_OFFSET) {
          if (this$._bootstrap_node && command !== UNCOMPRESSED_CORE_COMMAND_BOOTSTRAP_NODE) {
            return;
          }
          this$._handle_uncompressed_core_command(peer_id, command - UNCOMPRESSED_CORE_COMMANDS_OFFSET, command_data);
        } else if (command === ROUTING_COMMANDS) {
          if (this$._bootstrap_node) {
            return;
          }
          this$._router['process_packet'](peer_id, command_data);
        } else if (command >= DHT_COMMANDS_OFFSET) {
          this$._dht['receive'](peer_id, command - DHT_COMMANDS_OFFSET, command_data);
        } else {
          if (this$._bootstrap_node && command !== COMPRESSED_CORE_COMMAND_SIGNAL) {
            return;
          }
          this$._handle_compressed_core_command(peer_id, command, command_data);
        }
      });
      this._dht = detoxDht['DHT'](this._dht_public_key, bucket_size, this._options['state_history_size'], this._options['values_cache_size'], this._options['fraction_of_nodes_from_same_peer'], this._options['timeouts'])['on']('peer_error', function(peer_id){
        this$._peer_error(peer_id);
      })['on']('peer_warning', function(peer_id){
        this$._peer_warning(peer_id);
      })['on']('connect_to', function(peer_peer_id, peer_id){
        return new Promise(function(resolve, reject){
          var connection;
          if (this$._connected_nodes.has(peer_peer_id)) {
            resolve();
            return;
          }
          connection = this$._transport['get_connection'](peer_peer_id);
          if (!connection) {
            connection = this$._transport['create_connection'](true, peer_peer_id);
            if (!connection) {
              reject();
              return;
            }
            connection['on']('signal', function(sdp){
              var signature, command_data;
              signature = detoxCrypto['sign'](sdp, this$._dht_public_key, this$._dht_private_key);
              command_data = compose_signal(this$._dht_public_key, peer_peer_id, sdp, signature);
              this$._send_compressed_core_command(peer_id, COMPRESSED_CORE_COMMAND_SIGNAL, command_data);
            });
          }
          connection['once']('connected', function(){
            connection['off']('disconnected', disconnected);
            resolve();
          })['once']('disconnected', disconnected);
          function disconnected(){
            reject();
          }
        });
      })['on']('send', function(peer_id, command, command_data){
        this$._send_dht_command(peer_id, command, command_data);
      })['on']('peer_updated', function(peer_id, peer_peers){
        var i$, len$, peer_peer_id;
        this$._peers.add(peer_id);
        for (i$ = 0, len$ = peer_peers.length; i$ < len$; ++i$) {
          peer_peer_id = peer_peers[i$];
          if (!this$._connected_nodes.has(peer_peer_id)) {
            this$._aware_of_nodes.set(peer_peer_id, +new Date);
          }
        }
      });
      this._router = detoxRouting['Router'](this._dht_keypair['x25519']['private'], this._options['max_pending_segments'], this._options['timeouts']['ROUTING_PATH_SEGMENT_TIMEOUT'])['on']('activity', function(node_id, route_id){
        var source_id;
        source_id = concat_arrays(node_id, route_id);
        if (!this$._routing_paths.has(source_id)) {
          this$._routing_paths.set(source_id, [node_id, route_id]);
        }
        this$._routes_timeouts.set(source_id, +new Date);
      })['on']('send', function(node_id, data){
        this$._send_routing_command(node_id, data);
      })['on']('data', function(node_id, route_id, command, data){
        var source_id, public_key, announce_interval, target_id, send_response, ref$, rendezvous_token, introduction_node, introduction_message, connection_timeout, signature, handshake_message, pending_connection, target_node_id, target_route_id, target_source_id, routing_path_details, real_public_key, real_keypair, announced_to, introduction_message_decrypted, introduction_payload, rendezvous_node, application, secret, for_signature, full_target_id, connection_in_progress, i$, len$, key, item, error, encryptor_instance, demultiplexer, data_decrypted, data_with_header;
        source_id = concat_arrays(node_id, route_id);
        switch (command) {
        case ROUTING_COMMAND_ANNOUNCE:
          public_key = this$._verify_announcement_message(data);
          if (!public_key) {
            return;
          }
          if (this$._announcements_from.has(public_key)) {
            clearInterval(this$._announcements_from.get(public_key)[2]);
          }
          announce_interval = intervalSet(this$._options['timeouts']['ANNOUNCE_INTERVAL'], function(){
            if (!this$._routing_paths.has(source_id)) {
              return;
            }
            this$._publish_announcement_message(data);
          });
          this$._announcements_from.set(public_key, [node_id, route_id, announce_interval]);
          this$._publish_announcement_message(data);
          break;
        case ROUTING_COMMAND_FIND_INTRODUCTION_NODES_REQUEST:
          target_id = data;
          if (target_id.length !== PUBLIC_KEY_LENGTH) {
            return;
          }
          /**
           * @param {number}				code
           * @param {!Array<!Uint8Array>}	nodes
           */
          send_response = function(code, nodes){
            var data;
            data = compose_find_introduction_nodes_response(code, target_id, nodes);
            this$._send_to_routing_path(node_id, route_id, ROUTING_COMMAND_FIND_INTRODUCTION_NODES_RESPONSE, data);
          };
          this$._find_introduction_nodes(target_id).then(function(introduction_nodes){
            if (!introduction_nodes.length) {
              send_response(CONNECTION_ERROR_NO_INTRODUCTION_NODES, []);
            } else {
              send_response(CONNECTION_OK, introduction_nodes);
            }
          })['catch'](function(error){
            error_handler(error);
            send_response(CONNECTION_ERROR_NO_INTRODUCTION_NODES, []);
          });
          break;
        case ROUTING_COMMAND_INITIALIZE_CONNECTION:
          ref$ = parse_initialize_connection_data(data), rendezvous_token = ref$[0], introduction_node = ref$[1], target_id = ref$[2], introduction_message = ref$[3];
          if (this$._pending_connections.has(rendezvous_token)) {
            return;
          }
          connection_timeout = timeoutSet(this$._options['timeouts']['CONNECTION_TIMEOUT'], function(){
            this$._pending_connections['delete'](rendezvous_token);
          });
          this$._pending_connections.set(rendezvous_token, [node_id, route_id, target_id, connection_timeout]);
          this$._send_uncompressed_core_command(introduction_node, UNCOMPRESSED_CORE_COMMAND_FORWARD_INTRODUCTION, compose_introduce_to_data(target_id, introduction_message));
          break;
        case ROUTING_COMMAND_CONFIRM_CONNECTION:
          ref$ = parse_confirm_connection_data(data), signature = ref$[0], rendezvous_token = ref$[1], handshake_message = ref$[2];
          pending_connection = this$._pending_connections.get(rendezvous_token);
          if (!pending_connection) {
            return;
          }
          target_node_id = pending_connection[0], target_route_id = pending_connection[1], target_id = pending_connection[2], connection_timeout = pending_connection[3];
          if (!detoxCrypto['verify'](signature, rendezvous_token, target_id)) {
            return;
          }
          this$._pending_connections['delete'](rendezvous_token);
          clearTimeout(connection_timeout);
          this$._send_to_routing_path(target_node_id, target_route_id, ROUTING_COMMAND_CONNECTED, data);
          target_source_id = concat_arrays(target_node_id, target_route_id);
          this$._forwarding_mapping.set(source_id, [target_node_id, target_route_id]);
          this$._forwarding_mapping.set(target_source_id, [node_id, route_id]);
          break;
        case ROUTING_COMMAND_INTRODUCTION:
          routing_path_details = this$._routing_path_to_id.get(source_id);
          if (!routing_path_details) {
            return;
          }
          real_public_key = routing_path_details[0], introduction_node = routing_path_details[1];
          if (!this$._real_keypairs.has(real_public_key)) {
            return;
          }
          ref$ = this$._real_keypairs.get(real_public_key), real_keypair = ref$[0], announced_to = ref$[3];
          if (!announced_to.has(introduction_node)) {
            return;
          }
          try {
            introduction_message_decrypted = detoxCrypto['one_way_decrypt'](real_keypair['x25519']['private'], data);
            signature = introduction_message_decrypted.subarray(0, SIGNATURE_LENGTH);
            introduction_payload = introduction_message_decrypted.subarray(SIGNATURE_LENGTH);
            ref$ = parse_introduction_payload(introduction_payload), target_id = ref$[0], rendezvous_node = ref$[1], rendezvous_token = ref$[2], handshake_message = ref$[3], application = ref$[4], secret = ref$[5];
            for_signature = concat_arrays(introduction_node, introduction_payload);
            if (!detoxCrypto['verify'](signature, for_signature, target_id)) {
              return;
            }
            full_target_id = concat_arrays(real_public_key, target_id);
            if (this$._id_to_routing_path.has(full_target_id)) {
              return;
            }
            if (this$._connections_in_progress.has(full_target_id)) {
              connection_in_progress = this$._connections_in_progress.get(full_target_id);
              if (connection_in_progress.initiator && !connection_in_progress.discarded) {
                for (i$ = 0, len$ = real_public_key.length; i$ < len$; ++i$) {
                  key = i$;
                  item = real_public_key[i$];
                  if (item === target_id[key]) {
                    continue;
                  }
                  if (item > target_id[key]) {
                    return;
                  } else {
                    connection_in_progress.discarded = true;
                    break;
                  }
                }
              }
            } else {
              connection_in_progress = {
                initiator: false
              };
              this$._connections_in_progress.set(full_target_id, connection_in_progress);
            }
            data = {
              'real_public_key': real_public_key,
              'target_id': target_id,
              'secret': secret,
              'application': application,
              'number_of_intermediate_nodes': null
            };
            this$['fire']('introduction', data).then(function(){
              var number_of_intermediate_nodes, nodes, first_node;
              number_of_intermediate_nodes = data['number_of_intermediate_nodes'];
              if (number_of_intermediate_nodes === null) {
                throw 'No event handler for introduction';
              }
              if (!number_of_intermediate_nodes) {
                throw new Error('Direct connections are not yet supported');
              }
              nodes = this$._pick_nodes_for_routing_path(number_of_intermediate_nodes, [rendezvous_node]);
              if (!nodes) {
                return;
              }
              nodes.push(rendezvous_node);
              first_node = nodes[0];
              this$._construct_routing_path(nodes).then(function(route_id){
                var encryptor_instance, response_handshake_message, signature;
                encryptor_instance = detoxCrypto['Encryptor'](false, real_keypair['x25519']['private']);
                encryptor_instance['put_handshake_message'](handshake_message);
                response_handshake_message = encryptor_instance['get_handshake_message']();
                this$._encryptor_instances.set(full_target_id, encryptor_instance);
                this$._register_routing_path(real_public_key, target_id, first_node, route_id);
                this$._connections_in_progress['delete'](full_target_id);
                this$._register_application_connection(real_public_key, target_id);
                signature = detoxCrypto['sign'](rendezvous_token, real_public_key, real_keypair['ed25519']['private']);
                this$._send_to_routing_node(real_public_key, target_id, ROUTING_COMMAND_CONFIRM_CONNECTION, compose_confirm_connection_data(signature, rendezvous_token, response_handshake_message));
              })['catch'](function(error){
                error_handler(error);
                this$._connections_in_progress['delete'](full_target_id);
                if (connection_in_progress.initiator && connection_in_progress.discarded) {
                  this$['fire']('connection_failed', real_public_key, target_id, CONNECTION_ERROR_CANT_CONNECT_TO_RENDEZVOUS_NODE);
                }
              });
            })['catch'](function(error){
              error_handler(error);
              this$._connections_in_progress['delete'](full_target_id);
              if (connection_in_progress.initiator && connection_in_progress.discarded) {
                this$['fire']('connection_failed', real_public_key, target_id, CONNECTION_ERROR_CANT_CONNECT_TO_RENDEZVOUS_NODE);
              }
            });
          } catch (e$) {
            error = e$;
            error_handler(error);
          }
          break;
        case ROUTING_COMMAND_DATA:
          if (this$._forwarding_mapping.has(source_id)) {
            ref$ = this$._forwarding_mapping.get(source_id), target_node_id = ref$[0], target_route_id = ref$[1];
            this$._send_to_routing_path(target_node_id, target_route_id, ROUTING_COMMAND_DATA, data);
          } else if (this$._routing_path_to_id.has(source_id)) {
            ref$ = this$._routing_path_to_id.get(source_id), real_public_key = ref$[0], target_id = ref$[1];
            full_target_id = concat_arrays(real_public_key, target_id);
            encryptor_instance = this$._encryptor_instances.get(full_target_id);
            if (!encryptor_instance) {
              return;
            }
            demultiplexer = this$._demultiplexers.get(full_target_id);
            if (!demultiplexer) {
              return;
            }
            data_decrypted = encryptor_instance['decrypt'](data);
            demultiplexer['feed'](data_decrypted);
            while (demultiplexer['have_more_data']()) {
              data_with_header = demultiplexer['get_data']();
              command = data_with_header[0];
              this$['fire']('data', real_public_key, target_id, command, data_with_header.subarray(1));
            }
          }
          break;
        case ROUTING_COMMAND_PING:
          if (this$._routing_path_to_id.has(source_id)) {
            if (this$._pending_pings.has(source_id)) {
              this$._pending_pings['delete'](source_id);
              return;
            }
          }
          this$._send_ping(node_id, route_id);
        }
      });
      this._max_packet_data_size = this._router['get_max_packet_data_size']() - MAC_LENGTH;
      if (!this._bootstrap_nodes.size) {
        setTimeout(function(){
          this$['fire']('ready');
        });
      } else {
        this._dht['once']('peer_updated', function(){
          this$['fire']('ready');
        });
      }
      this._do_random_lookup();
    }
    Core['CONNECTION_ERROR_CANT_FIND_INTRODUCTION_NODES'] = CONNECTION_ERROR_CANT_FIND_INTRODUCTION_NODES;
    Core['CONNECTION_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES'] = CONNECTION_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES;
    Core['CONNECTION_ERROR_NO_INTRODUCTION_NODES'] = CONNECTION_ERROR_NO_INTRODUCTION_NODES;
    Core['CONNECTION_ERROR_CANT_CONNECT_TO_RENDEZVOUS_NODE'] = CONNECTION_ERROR_CANT_CONNECT_TO_RENDEZVOUS_NODE;
    Core['CONNECTION_ERROR_OUT_OF_INTRODUCTION_NODES'] = CONNECTION_ERROR_OUT_OF_INTRODUCTION_NODES;
    Core['CONNECTION_PROGRESS_CONNECTED_TO_RENDEZVOUS_NODE'] = CONNECTION_PROGRESS_CONNECTED_TO_RENDEZVOUS_NODE;
    Core['CONNECTION_PROGRESS_FOUND_INTRODUCTION_NODES'] = CONNECTION_PROGRESS_FOUND_INTRODUCTION_NODES;
    Core['CONNECTION_PROGRESS_INTRODUCTION_SENT'] = CONNECTION_PROGRESS_INTRODUCTION_SENT;
    Core['ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONNECTED'] = ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONNECTED;
    Core['ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONFIRMED'] = ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONFIRMED;
    Core['ANNOUNCEMENT_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES'] = ANNOUNCEMENT_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES;
    Core.prototype = {
      /**
       * Start HTTP server listening on specified ip:port, so that current node will be capable of acting as bootstrap node for other users
       *
       * @param {!Uint8Array}	bootstrap_seed	Seed for generating bootstrap node's keypairs
       * @param {string}		ip
       * @param {number}		port
       * @param {string}		public_address	Publicly available address that will be returned to other node, typically domain name (instead of using IP)
       * @param {number}		public_port		Publicly available port on `public_address`
       */
      'start_bootstrap_node': function(bootstrap_seed, ip, port, public_address, public_port){
        var keypair, this$ = this;
        public_address == null && (public_address = ip);
        public_port == null && (public_port = port);
        keypair = detoxCrypto['create_keypair'](bootstrap_seed)['ed25519'];
        this._http_server = require('http')['createServer'](function(request, response){
          var content_length, body;
          response['setHeader']('Access-Control-Allow-Origin', '*');
          response['setHeader']('Connection', 'close');
          content_length = request.headers['content-length'];
          if (!(request.method === 'POST' && content_length && content_length <= this$._max_compressed_data_size)) {
            response['writeHead'](400);
            response['end']();
            return;
          }
          body = [];
          request['on']('data', function(chunk){
            body.push(chunk);
          })['on']('end', function(){
            var ref$, source_id, target_id, sdp, signature, random_connected_node, waiting_for_signal_key, command_data, timeout, connection;
            body = concat_arrays(body);
            ref$ = parse_signal(body), source_id = ref$[0], target_id = ref$[1], sdp = ref$[2], signature = ref$[3];
            if (!(detoxCrypto['verify'](signature, sdp, source_id) && are_arrays_equal(target_id, null_id))) {
              response['writeHead'](400);
              response['end']();
              return;
            }
            if (!this$._connected_nodes.size || !random_int(0, this$._connected_nodes.size)) {
              random_connected_node = null;
            } else {
              random_connected_node = (ref$ = this$._pick_random_connected_nodes(1)) != null ? ref$[0] : void 8;
            }
            if (random_connected_node) {
              waiting_for_signal_key = concat_arrays(source_id, random_connected_node);
              if (this$._waiting_for_signal.has(waiting_for_signal_key)) {
                response['writeHead'](503);
                response['end']();
                return;
              }
              command_data = compose_signal(source_id, random_connected_node, sdp, signature);
              this$._send_compressed_core_command(random_connected_node, COMPRESSED_CORE_COMMAND_SIGNAL, command_data);
              this$._waiting_for_signal.set(waiting_for_signal_key, function(sdp, signature, command_data){
                var data;
                clearTimeout(timeout);
                if (detoxCrypto['verify'](signature, sdp, random_connected_node)) {
                  data = compose_bootstrap_response(command_data, detoxCrypto['sign'](command_data, keypair['public'], keypair['private']));
                  response['write'](Buffer.from(data));
                  response['end']();
                } else {
                  response['writeHead'](502);
                  response['end']();
                }
              });
              timeout = timeoutSet(this$._options['timeouts']['CONNECTION_TIMEOUT'], function(){
                this$._waiting_for_signal['delete'](waiting_for_signal_key);
                response['writeHead'](504);
                response['end']();
              });
            } else {
              connection = this$._transport['create_connection'](false, source_id);
              if (!connection) {
                response['writeHead'](503);
                response['end']();
                return;
              }
              connection['once']('signal', function(sdp){
                var signature, command_data, data;
                signature = detoxCrypto['sign'](sdp, this$._dht_public_key, this$._dht_private_key);
                command_data = compose_signal(this$._dht_public_key, source_id, sdp, signature);
                data = compose_bootstrap_response(command_data, detoxCrypto['sign'](command_data, keypair['public'], keypair['private']));
                response['write'](Buffer.from(data));
                response['end']();
                return false;
              })['signal'](sdp);
            }
          });
        });
        this._http_server['on']('error', error_handler)['listen'](port, ip, function(){
          var node_id;
          node_id = array2hex(keypair['public']);
          this$._bootstrap_node = node_id + ":" + public_address + ":" + public_port;
        });
        this._destroy_router();
      }
      /**
       * Get an array of bootstrap nodes obtained during DHT operation in the same format as `bootstrap_nodes` argument in constructor
       *
       * @return {!Array<string>}
       */,
      'get_bootstrap_nodes': function(){
        return Array.from(this._bootstrap_nodes);
      }
      /**
       * @param {Function=} callback
       */,
      _bootstrap: function(callback){
        var waiting_for, this$ = this;
        waiting_for = this._bootstrap_nodes.size;
        if (!waiting_for) {
          if (typeof callback == 'function') {
            callback();
          }
          return;
        }
        function done(){
          --waiting_for;
          if (waiting_for) {
            return;
          }
          if (typeof callback == 'function') {
            callback();
          }
        }
        this._bootstrap_nodes.forEach(function(bootstrap_node){
          var bootstrap_node_id, bootstrap_node_address, random_id, connection;
          bootstrap_node = bootstrap_node.split(':');
          bootstrap_node_id = hex2array(bootstrap_node[0]);
          bootstrap_node_address = bootstrap_node[1] + ':' + bootstrap_node[2];
          random_id = random_bytes(PUBLIC_KEY_LENGTH);
          connection = this$._transport['create_connection'](true, random_id);
          if (!connection) {
            return;
          }
          connection['on']('signal', function(sdp){
            var signature, init;
            signature = detoxCrypto['sign'](sdp, this$._dht_public_key, this$._dht_private_key);
            init = {
              'method': 'POST',
              'headers': {
                'Connection': 'close'
              },
              'body': compose_signal(this$._dht_public_key, null_id, sdp, signature).buffer
            };
            fetch("https://" + bootstrap_node_address, init)['catch'](function(error){
              if (typeof location === 'undefined' || location['protocol'] === 'http:') {
                return fetch("http://" + bootstrap_node_address, init);
              } else {
                throw error;
              }
            }).then(function(response){
              if (!response['ok']) {
                throw 'Request failed, status code ' + response['status'];
              }
              return response['arrayBuffer']();
            }).then(function(buffer){
              return new Uint8Array(buffer);
            }).then(function(data){
              var ref$, signal, signature, source_id, target_id, sdp;
              ref$ = parse_bootstrap_response(data), signal = ref$[0], signature = ref$[1];
              if (!detoxCrypto['verify'](signature, signal, bootstrap_node_id)) {
                throw 'Bad bootstrap node response';
              }
              ref$ = parse_signal(signal), source_id = ref$[0], target_id = ref$[1], sdp = ref$[2], signature = ref$[3];
              if (!(detoxCrypto['verify'](signature, sdp, source_id) && are_arrays_equal(target_id, this$._dht_public_key))) {
                throw 'Bad response';
              }
              if (this$._transport['get_connection'](source_id)) {
                throw 'Already connected';
              }
              this$._transport['update_peer_id'](random_id, source_id);
              connection['signal'](sdp);
            })['catch'](function(error){
              connection['destroy']();
            });
          })['once']('connected', function(){
            connection['off']('disconnected', disconnected);
            done();
          })['once']('disconnected', disconnected);
          function disconnected(){
            done();
          }
        });
      }
      /**
       * @param {!Uint8Array}	real_key_seed					Seed used to generate real long-term keypair
       * @param {number}		number_of_introduction_nodes
       * @param {number}		number_of_intermediate_nodes	How many hops should be made until introduction node (not including it)
       *
       * @return {Uint8Array} Real public key or `null` in case of failure
       */,
      'announce': function(real_key_seed, number_of_introduction_nodes, number_of_intermediate_nodes){
        var real_keypair, real_public_key;
        if (this._bootstrap_node) {
          return null;
        }
        real_keypair = create_keypair(real_key_seed);
        real_public_key = real_keypair['ed25519']['public'];
        if (this._real_keypairs.has(real_public_key)) {
          return null;
        }
        this._real_keypairs.set(real_public_key, [real_keypair, number_of_introduction_nodes, number_of_intermediate_nodes, ArraySet()]);
        this._announce(real_public_key);
        return real_public_key;
      }
      /**
       * @param {!Uint8Array} real_public_key
       */,
      _announce: function(real_public_key){
        var ref$, real_keypair, number_of_introduction_nodes, number_of_intermediate_nodes, announced_to, old_introduction_nodes, introduction_nodes, introductions_pending, introduction_nodes_confirmed, i$, len$, this$ = this;
        ref$ = this._real_keypairs.get(real_public_key), real_keypair = ref$[0], number_of_introduction_nodes = ref$[1], number_of_intermediate_nodes = ref$[2], announced_to = ref$[3];
        old_introduction_nodes = [];
        announced_to.forEach(function(introduction_node){
          old_introduction_nodes.push(introduction_node);
        });
        number_of_introduction_nodes = number_of_introduction_nodes - old_introduction_nodes.length;
        if (!number_of_introduction_nodes) {
          return;
        }
        this._update_last_announcement(real_public_key, +new Date);
        introduction_nodes = this._pick_random_aware_of_nodes(number_of_introduction_nodes, old_introduction_nodes);
        if (!introduction_nodes) {
          this._update_last_announcement(real_public_key, 1);
          this['fire']('announcement_failed', real_public_key, ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONNECTED);
          return;
        }
        introductions_pending = number_of_introduction_nodes;
        introduction_nodes_confirmed = [];
        /**
         * @param {!Uint8Array=} introduction_node
         */
        function announced(introduction_node){
          var announcement_message, i$, len$;
          if (introduction_node) {
            introduction_nodes_confirmed.push(introduction_node);
          }
          --introductions_pending;
          if (introductions_pending) {
            return;
          }
          if (!introduction_nodes_confirmed.length) {
            this$._update_last_announcement(real_public_key, 1);
            this$['fire']('announcement_failed', real_public_key, ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONFIRMED);
            return;
          }
          introduction_nodes_confirmed = introduction_nodes_confirmed.concat(old_introduction_nodes);
          announcement_message = this$._generate_announcement_message(real_public_key, real_keypair['ed25519']['private'], introduction_nodes_confirmed);
          for (i$ = 0, len$ = introduction_nodes_confirmed.length; i$ < len$; ++i$) {
            introduction_node = introduction_nodes_confirmed[i$];
            this$._send_to_routing_node(real_public_key, introduction_node, ROUTING_COMMAND_ANNOUNCE, announcement_message);
          }
          this$['fire']('announced', real_public_key);
        }
        for (i$ = 0, len$ = introduction_nodes.length; i$ < len$; ++i$) {
          (fn$.call(this, introduction_nodes[i$]));
        }
        function fn$(introduction_node){
          var nodes, first_node, this$ = this;
          nodes = this._pick_nodes_for_routing_path(number_of_intermediate_nodes, introduction_nodes.concat(old_introduction_nodes));
          if (!nodes) {
            this['fire']('announcement_failed', real_public_key, ANNOUNCEMENT_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES);
            return;
          }
          nodes.push(introduction_node);
          first_node = nodes[0];
          this._construct_routing_path(nodes).then(function(route_id){
            this$._register_routing_path(real_public_key, introduction_node, first_node, route_id);
            announced_to.add(introduction_node);
            announced(introduction_node);
          })['catch'](function(error){
            error_handler(error);
            announced();
          });
        }
      }
      /**
       * @param {!Uint8Array}	real_public_key
       * @param {number}		value
       */,
      _update_last_announcement: function(real_public_key, value){
        this._real_keypairs.get(real_public_key)[4] = value;
      }
      /**
       * @param {!Uint8Array}	real_key_seed					Seed used to generate real long-term keypair
       * @param {!Uint8Array}	target_id						Real Ed25519 pubic key of interested node
       * @param {!Uint8Array}	application						Up to 64 bytes
       * @param {!Uint8Array}	secret							Up to 32 bytes
       * @param {number}		number_of_intermediate_nodes	How many hops should be made until rendezvous node (including it)
       *
       * @return {Uint8Array} Real public key or `null` in case of failure
       */,
      'connect_to': function(real_key_seed, target_id, application, secret, number_of_intermediate_nodes){
        var real_keypair, real_public_key, full_target_id, connection_in_progress, nodes, first_node, rendezvous_node, this$ = this;
        if (this._bootstrap_node) {
          return null;
        }
        if (!number_of_intermediate_nodes) {
          throw new Error('Direct connections are not yet supported');
        }
        real_keypair = create_keypair(real_key_seed);
        real_public_key = real_keypair['ed25519']['public'];
        if (are_arrays_equal(real_public_key, target_id)) {
          return null;
        }
        full_target_id = concat_arrays(real_public_key, target_id);
        if (this._connections_in_progress.has(full_target_id)) {
          return real_public_key;
        }
        connection_in_progress = {
          initiator: true,
          discarded: false
        };
        this._connections_in_progress.set(full_target_id, connection_in_progress);
        if (this._id_to_routing_path.has(full_target_id)) {
          return null;
        }
        function connection_failed(code){
          if (connection_in_progress.discarded) {
            return;
          }
          this$._connections_in_progress['delete'](full_target_id);
          if (first_node) {
            this$._used_first_nodes['delete'](first_node);
          }
          this$['fire']('connection_failed', real_public_key, target_id, code);
        }
        nodes = this._pick_nodes_for_routing_path(number_of_intermediate_nodes);
        if (!nodes) {
          connection_failed(CONNECTION_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES);
          return null;
        }
        first_node = nodes[0];
        rendezvous_node = nodes[nodes.length - 1];
        this._construct_routing_path(nodes).then(function(route_id){
          var find_introduction_nodes_timeout;
          this$['fire']('connection_progress', real_public_key, target_id, CONNECTION_PROGRESS_CONNECTED_TO_RENDEZVOUS_NODE);
          function found_introduction_nodes(new_node_id, new_route_id, command, data){
            var ref$, code, introduction_target_id, introduction_nodes;
            if (!(are_arrays_equal(first_node, new_node_id) && are_arrays_equal(route_id, new_route_id) && command === ROUTING_COMMAND_FIND_INTRODUCTION_NODES_RESPONSE)) {
              return;
            }
            ref$ = parse_find_introduction_nodes_response(data), code = ref$[0], introduction_target_id = ref$[1], introduction_nodes = ref$[2];
            if (!are_arrays_equal(target_id, introduction_target_id)) {
              return;
            }
            clearTimeout(find_introduction_nodes_timeout);
            if (code !== CONNECTION_OK) {
              connection_failed(code);
              return;
            }
            this$['fire']('connection_progress', real_public_key, target_id, CONNECTION_PROGRESS_FOUND_INTRODUCTION_NODES);
            function try_to_introduce(){
              var introduction_node, rendezvous_token, x25519_public_key, encryptor_instance, handshake_message, introduction_payload, for_signature, signature, introduction_message, introduction_message_encrypted, path_confirmation_timeout;
              if (connection_in_progress.discarded) {
                return;
              }
              if (!introduction_nodes.length) {
                connection_failed(CONNECTION_ERROR_OUT_OF_INTRODUCTION_NODES);
                return;
              }
              introduction_node = pull_random_item_from_array(introduction_nodes);
              rendezvous_token = random_bytes(PUBLIC_KEY_LENGTH);
              x25519_public_key = detoxCrypto['convert_public_key'](target_id);
              encryptor_instance = detoxCrypto['Encryptor'](true, x25519_public_key);
              handshake_message = encryptor_instance['get_handshake_message']();
              introduction_payload = compose_introduction_payload(real_public_key, rendezvous_node, rendezvous_token, handshake_message, application, secret);
              for_signature = concat_arrays(introduction_node, introduction_payload);
              signature = detoxCrypto['sign'](for_signature, real_public_key, real_keypair['ed25519']['private']);
              introduction_message = concat_arrays(signature, introduction_payload);
              introduction_message_encrypted = detoxCrypto['one_way_encrypt'](x25519_public_key, introduction_message);
              function path_confirmation(new_node_id, new_route_id, command, data){
                var ref$, signature, rendezvous_token_received, handshake_message_received;
                if (!(are_arrays_equal(first_node, new_node_id) && are_arrays_equal(route_id, new_route_id) && command === ROUTING_COMMAND_CONNECTED)) {
                  return;
                }
                ref$ = parse_confirm_connection_data(data), signature = ref$[0], rendezvous_token_received = ref$[1], handshake_message_received = ref$[2];
                if (!(are_arrays_equal(rendezvous_token_received, rendezvous_token) && detoxCrypto['verify'](signature, rendezvous_token, target_id))) {
                  return;
                }
                encryptor_instance['put_handshake_message'](handshake_message_received);
                this$._encryptor_instances.set(full_target_id, encryptor_instance);
                clearTimeout(path_confirmation_timeout);
                this$._router['off']('data', path_confirmation);
                this$._register_routing_path(real_public_key, target_id, first_node, route_id);
                this$._connections_in_progress['delete'](full_target_id);
                this$._register_application_connection(real_public_key, target_id);
              }
              this$._router['on']('data', path_confirmation);
              this$._send_to_routing_path(first_node, route_id, ROUTING_COMMAND_INITIALIZE_CONNECTION, compose_initialize_connection_data(rendezvous_token, introduction_node, target_id, introduction_message_encrypted));
              this$['fire']('connection_progress', real_public_key, target_id, CONNECTION_PROGRESS_INTRODUCTION_SENT);
              path_confirmation_timeout = timeoutSet(this$._options['timeouts']['CONNECTION_TIMEOUT'], function(){
                this$._router['off']('data', path_confirmation);
                encryptor_instance['destroy']();
                try_to_introduce();
              });
            }
            try_to_introduce();
          }
          this$._router['on']('data', found_introduction_nodes);
          this$._send_to_routing_path(first_node, route_id, ROUTING_COMMAND_FIND_INTRODUCTION_NODES_REQUEST, target_id);
          find_introduction_nodes_timeout = timeoutSet(this$._options['timeouts']['CONNECTION_TIMEOUT'], function(){
            this$._router['off']('data', found_introduction_nodes);
            connection_failed(CONNECTION_ERROR_CANT_FIND_INTRODUCTION_NODES);
          });
        })['catch'](function(error){
          error_handler(error);
          connection_failed(CONNECTION_ERROR_CANT_CONNECT_TO_RENDEZVOUS_NODE);
        });
        return real_public_key;
      },
      'get_max_data_size': function(){
        return this._max_data_size;
      }
      /**
       * @param {!Uint8Array}	real_public_key	Own real long-term public key as returned by `announce()` and `connect_to()` methods
       * @param {!Uint8Array}	target_id		Should be connected already
       * @param {number}		command			Command from range `0..255`
       * @param {!Uint8Array}	data			Size limit can be obtained with `get_max_data_size()` method, roughly 65KiB
       */,
      'send_to': function(real_public_key, target_id, command, data){
        var full_target_id, encryptor_instance, multiplexer, data_with_header, this$ = this;
        if (this._bootstrap_node) {
          return;
        }
        full_target_id = concat_arrays(real_public_key, target_id);
        encryptor_instance = this._encryptor_instances.get(full_target_id);
        if (!encryptor_instance || data.length > this._max_data_size) {
          return;
        }
        multiplexer = this._multiplexers.get(full_target_id);
        if (!multiplexer) {
          return;
        }
        data_with_header = concat_arrays([command], data);
        multiplexer['feed'](data_with_header);
        if (this._pending_sending.has(full_target_id)) {
          return;
        }
        this._pending_sending.set(full_target_id, setTimeout(function(){
          var data_block, data_block_encrypted;
          this$._pending_sending['delete'](full_target_id);
          while (multiplexer['have_more_blocks']()) {
            data_block = multiplexer['get_block']();
            data_block_encrypted = encryptor_instance['encrypt'](data_block);
            this$._send_to_routing_node(real_public_key, target_id, ROUTING_COMMAND_DATA, data_block_encrypted);
          }
        }));
      },
      'destroy': function(){
        if (this._destroyed) {
          return;
        }
        this._destroyed = true;
        if (!this._bootstrap_node) {
          this._destroy_router();
        } else if (this._http_server) {
          this._http_server.close();
        }
        clearTimeout(this._random_lookup_timeout);
        this._transport['destroy']();
        this._dht['destroy']();
      },
      _destroy_router: function(){
        var this$ = this;
        clearInterval(this._cleanup_interval);
        clearInterval(this._keep_announce_routes_interval);
        clearInterval(this._get_more_nodes_interval);
        this._routing_paths.forEach(function(arg$){
          var node_id, route_id;
          node_id = arg$[0], route_id = arg$[1];
          this$._unregister_routing_path(node_id, route_id);
        });
        this._pending_connections.forEach(function(arg$){
          var connection_timeout;
          connection_timeout = arg$[3];
          clearTimeout(connection_timeout);
        });
        this._router['destroy']();
      }
      /**
       * @return {boolean}
       */,
      _more_aware_of_nodes_needed: function(){
        return !this._bootstrap_node && !!(this._aware_of_nodes.size < this._options['aware_of_nodes_limit'] || this._get_stale_aware_of_nodes(true).length);
      }
      /**
       * @param {boolean=} early_exit Will return single node if present, used to check if stale nodes are present at all
       *
       * @return {!Array<string>}
       */,
      _get_stale_aware_of_nodes: function(early_exit){
        var stale_aware_of_nodes, stale_older_than, exited;
        early_exit == null && (early_exit = false);
        stale_aware_of_nodes = [];
        stale_older_than = +new Date - this._options['timeouts']['STALE_AWARE_OF_NODE_TIMEOUT'] * 1000;
        exited = false;
        this._aware_of_nodes.forEach(function(date, node_id){
          if (!exited && date < stale_older_than) {
            stale_aware_of_nodes.push(node_id);
            if (early_exit && !exited) {
              exited = true;
            }
          }
        });
        return stale_aware_of_nodes;
      }
      /**
       * Request more nodes to be aware of from some of the nodes already connected to
       */,
      _get_more_aware_of_nodes: function(){
        var nodes, i$, len$, node_id;
        nodes = this._pick_random_connected_nodes(5);
        if (!nodes) {
          return;
        }
        for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
          node_id = nodes[i$];
          this._get_more_nodes_from(node_id);
        }
      }
      /**
       * @param {!Uint8Array} peer_id
       */,
      _get_more_nodes_from: function(peer_id){
        this._get_nodes_requested.add(peer_id);
        this._send_uncompressed_core_command(peer_id, UNCOMPRESSED_CORE_COMMAND_GET_NODES_REQUEST, empty_array);
      }
      /**
       * Get some random nodes suitable for constructing routing path through them or for acting as introduction nodes
       *
       * @param {number}					number_of_nodes
       * @param {!Array<!Uint8Array>=}	exclude_nodes
       *
       * @return {Array<!Uint8Array>} `null` if there was not enough nodes
       */,
      _pick_nodes_for_routing_path: function(number_of_nodes, exclude_nodes){
        var connected_node, ref$, intermediate_nodes;
        exclude_nodes == null && (exclude_nodes = []);
        exclude_nodes = Array.from(this._used_first_nodes.values()).concat(exclude_nodes);
        connected_node = (ref$ = this._pick_random_connected_nodes(1, exclude_nodes)) != null ? ref$[0] : void 8;
        if (!connected_node) {
          return null;
        }
        intermediate_nodes = this._pick_random_aware_of_nodes(number_of_nodes - 1, exclude_nodes.concat([connected_node]));
        if (!intermediate_nodes) {
          return null;
        }
        return [connected_node].concat(intermediate_nodes);
      }
      /**
       * Get some random nodes from already connected nodes
       *
       * @param {number=}					up_to_number_of_nodes
       * @param {!Array<!Uint8Array>=}	exclude_nodes
       *
       * @return {Array<!Uint8Array>} `null` if there is no nodes to return
       */,
      _pick_random_connected_nodes: function(up_to_number_of_nodes, exclude_nodes){
        var connected_nodes, exclude_nodes_set, i$, i, results$ = [];
        up_to_number_of_nodes == null && (up_to_number_of_nodes = 1);
        exclude_nodes == null && (exclude_nodes = []);
        if (!this._connected_nodes.size) {
          return null;
        }
        connected_nodes = Array.from(this._connected_nodes.values());
        exclude_nodes_set = ArraySet(exclude_nodes.concat(Array.from(this._bootstrap_nodes_ids)));
        connected_nodes = connected_nodes.filter(function(node){
          return !exclude_nodes_set.has(node);
        });
        if (!connected_nodes.length) {
          return null;
        }
        for (i$ = 0; i$ < up_to_number_of_nodes; ++i$) {
          i = i$;
          if (connected_nodes.length) {
            results$.push(pull_random_item_from_array(connected_nodes));
          }
        }
        return results$;
      }
      /**
       * Get some random nodes from those that current node is aware of
       *
       * @param {number}					number_of_nodes
       * @param {!Array<!Uint8Array>=}	exclude_nodes
       *
       * @return {Array<!Uint8Array>} `null` if there was not enough nodes
       */,
      _pick_random_aware_of_nodes: function(number_of_nodes, exclude_nodes){
        var aware_of_nodes, exclude_nodes_set, i$, i, results$ = [];
        if (this._aware_of_nodes.size < number_of_nodes) {
          return null;
        }
        aware_of_nodes = Array.from(this._aware_of_nodes.keys());
        if (exclude_nodes) {
          exclude_nodes_set = ArraySet(exclude_nodes);
          aware_of_nodes = aware_of_nodes.filter(function(node){
            return !exclude_nodes_set.has(node);
          });
        }
        if (aware_of_nodes.length < number_of_nodes) {
          return null;
        }
        for (i$ = 0; i$ < number_of_nodes; ++i$) {
          i = i$;
          results$.push(pull_random_item_from_array(aware_of_nodes));
        }
        return results$;
      },
      _do_random_lookup: function(){
        var timeout, this$ = this;
        if (this._destroyed) {
          return;
        }
        if (this._dht['get_peers']().length < this._bootstrap_nodes.size && this._bootstrap_nodes.size) {
          this._bootstrap(function(){
            if (this$._dht['get_peers']().length) {
              this$._do_random_lookup();
            } else {
              timeoutSet(1, function(){
                this$._do_random_lookup();
              });
            }
          });
          return;
        }
        timeout = sample(this._options['timeouts']['RANDOM_LOOKUPS_INTERVAL']);
        this._random_lookup_timeout = timeoutSet(this._random_lookup_timeout ? timeout : 0, function(){
          this$._dht['lookup'](fake_node_id(), this$._options['lookup_number']).then(function(){
            this$._do_random_lookup();
          })['catch'](function(){
            this$._do_random_lookup();
          });
        });
      }
      /**
       * @param {!Array<!Uint8Array>} nodes
       *
       * @return {!Promise}
       */,
      _construct_routing_path: function(nodes){
        var first_node, x$, this$ = this;
        first_node = nodes[0];
        this._used_first_nodes.add(first_node);
        x$ = this._router['construct_routing_path'](nodes);
        x$['catch'](function(error){
          error_handler(error);
          this$._used_first_nodes['delete'](first_node);
        });
        return x$;
      }
      /**
       * @param {!Uint8Array} real_public_key
       * @param {!Uint8Array} target_id		Last node in routing path, responder
       * @param {!Uint8Array} node_id			First node in routing path, used for routing path identification
       * @param {!Uint8Array} route_id		ID of the route on `node_id`
       */,
      _register_routing_path: function(real_public_key, target_id, node_id, route_id){
        var source_id, full_target_id;
        source_id = concat_arrays(node_id, route_id);
        if (this._routing_path_to_id.has(source_id)) {
          return;
        }
        full_target_id = concat_arrays(real_public_key, target_id);
        this._id_to_routing_path.set(full_target_id, [node_id, route_id]);
        this._routing_path_to_id.set(source_id, [real_public_key, target_id]);
        this._multiplexers.set(full_target_id, fixedSizeMultiplexer['Multiplexer'](this._max_data_size, this._max_packet_data_size));
        this._demultiplexers.set(full_target_id, fixedSizeMultiplexer['Demultiplexer'](this._max_data_size, this._max_packet_data_size));
        this['fire']('routing_paths_count', this._id_to_routing_path.size);
      }
      /**
       * @param {!Uint8Array} node_id		First node in routing path, used for routing path identification
       * @param {!Uint8Array} route_id	ID of the route on `node_id`
       */,
      _unregister_routing_path: function(node_id, route_id){
        var source_id, ref$, real_public_key, target_id, full_target_id, announced_to, encryptor_instance, this$ = this;
        source_id = concat_arrays(node_id, route_id);
        if (!this._routing_paths.has(source_id)) {
          return;
        }
        this._used_first_nodes['delete'](node_id);
        this._routing_paths['delete'](source_id);
        this._router['destroy_routing_path'](node_id, route_id);
        this._forwarding_mapping['delete'](source_id);
        this._pending_pings['delete'](source_id);
        this._announcements_from.forEach(function(arg$, target_id){
          var node_id, route_id, announce_interval, source_id_local;
          node_id = arg$[0], route_id = arg$[1], announce_interval = arg$[2];
          source_id_local = concat_arrays(node_id, route_id);
          if (!are_arrays_equal(source_id, source_id_local)) {
            return;
          }
          clearInterval(announce_interval);
          this$._announcements_from['delete'](target_id);
        });
        if (!this._routing_path_to_id.has(source_id)) {
          return;
        }
        ref$ = this._routing_path_to_id.get(source_id), real_public_key = ref$[0], target_id = ref$[1];
        full_target_id = concat_arrays(real_public_key, target_id);
        this._routing_path_to_id['delete'](source_id);
        this._id_to_routing_path['delete'](full_target_id);
        if (this._pending_sending.has(full_target_id)) {
          clearTimeout(this._pending_sending.get(full_target_id));
          this._pending_sending['delete'](full_target_id);
        }
        if (this._real_keypairs.has(real_public_key)) {
          announced_to = this._real_keypairs.get(real_public_key)[3];
          announced_to['delete'](target_id);
        }
        encryptor_instance = this._encryptor_instances.get(full_target_id);
        if (encryptor_instance) {
          encryptor_instance['destroy']();
          this._encryptor_instances['delete'](full_target_id);
        }
        this._multiplexers['delete'](full_target_id);
        this._demultiplexers['delete'](full_target_id);
        this._unregister_application_connection(real_public_key, target_id);
        this['fire']('routing_paths_count', this._id_to_routing_path.size);
      }
      /**
       * @param {!Uint8Array} real_public_key
       * @param {!Uint8Array} target_id		Last node in routing path, responder
       */,
      _register_application_connection: function(real_public_key, target_id){
        var full_target_id;
        full_target_id = concat_arrays(real_public_key, target_id);
        this._application_connections.add(full_target_id);
        this['fire']('connected', real_public_key, target_id);
        this['fire']('application_connections_count', this._application_connections.size);
      }
      /**
       * @param {!Uint8Array} real_public_key
       * @param {!Uint8Array} target_id		Last node in routing path, responder
       */,
      _unregister_application_connection: function(real_public_key, target_id){
        var full_target_id;
        full_target_id = concat_arrays(real_public_key, target_id);
        if (this._application_connections.has(full_target_id)) {
          this._application_connections['delete'](full_target_id);
          this['fire']('disconnected', real_public_key, target_id);
          this['fire']('application_connections_count', this._application_connections.size);
        }
      }
      /**
       * @param {!Uint8Array}	peer_id
       * @param {number}		command			0..9
       * @param {!Uint8Array}	command_data
       */,
      _handle_compressed_core_command: function(peer_id, command, command_data){
        var ref$, source_id, target_id, sdp, signature, waiting_for_signal_key, waiting_for_signal_callback, connection, this$ = this;
        switch (command) {
        case COMPRESSED_CORE_COMMAND_SIGNAL:
          ref$ = parse_signal(command_data), source_id = ref$[0], target_id = ref$[1], sdp = ref$[2], signature = ref$[3];
          if (!detoxCrypto['verify'](signature, sdp, source_id)) {
            this._peer_error(peer_id);
            return;
          }
          waiting_for_signal_key = concat_arrays(target_id, source_id);
          waiting_for_signal_callback = this._waiting_for_signal.get(waiting_for_signal_key);
          if (waiting_for_signal_callback) {
            this._waiting_for_signal['delete'](waiting_for_signal_key);
            waiting_for_signal_callback(sdp, signature, command_data);
            return;
          }
          if (this._connected_nodes.has(target_id) && are_arrays_equal(peer_id, source_id)) {
            this._send_compressed_core_command(target_id, COMPRESSED_CORE_COMMAND_SIGNAL, command_data);
            return;
          }
          if (!are_arrays_equal(target_id, this._dht_public_key)) {
            return;
          }
          connection = this._transport['get_connection'](source_id);
          if (!connection) {
            connection = this._transport['create_connection'](false, source_id);
            if (!connection) {
              return;
            }
            connection['on']('signal', function(sdp){
              var signature, command_data;
              signature = detoxCrypto['sign'](sdp, this$._dht_public_key, this$._dht_private_key);
              command_data = compose_signal(this$._dht_public_key, source_id, sdp, signature);
              this$._send_compressed_core_command(peer_id, COMPRESSED_CORE_COMMAND_SIGNAL, command_data);
            });
          }
          connection['signal'](sdp);
        }
      }
      /**
       * @param {!Uint8Array}	peer_id
       * @param {number}		command			0..9
       * @param {!Uint8Array}	command_data
       */,
      _handle_uncompressed_core_command: function(peer_id, command, command_data){
        var ref$, target_id, introduction_message, target_node_id, target_route_id, nodes, number_of_nodes, stale_aware_of_nodes, i$, i, new_node_id, stale_node_to_remove;
        switch (command) {
        case UNCOMPRESSED_CORE_COMMAND_FORWARD_INTRODUCTION:
          ref$ = parse_introduce_to_data(command_data), target_id = ref$[0], introduction_message = ref$[1];
          if (!this._announcements_from.has(target_id)) {
            return;
          }
          ref$ = this._announcements_from.get(target_id), target_node_id = ref$[0], target_route_id = ref$[1];
          this._send_to_routing_path(target_node_id, target_route_id, ROUTING_COMMAND_INTRODUCTION, introduction_message);
          break;
        case UNCOMPRESSED_CORE_COMMAND_GET_NODES_REQUEST:
          nodes = this._pick_random_connected_nodes(7) || [];
          nodes = nodes.concat(this._pick_random_aware_of_nodes(10 - nodes.length) || []);
          command_data = concat_arrays(nodes);
          this._send_uncompressed_core_command(peer_id, UNCOMPRESSED_CORE_COMMAND_GET_NODES_RESPONSE, command_data);
          break;
        case UNCOMPRESSED_CORE_COMMAND_GET_NODES_RESPONSE:
          if (!this._get_nodes_requested.has(peer_id)) {
            return;
          }
          this._get_nodes_requested['delete'](peer_id);
          if (!command_data.length || command_data.length % PUBLIC_KEY_LENGTH !== 0) {
            return;
          }
          number_of_nodes = command_data.length / PUBLIC_KEY_LENGTH;
          stale_aware_of_nodes = this._get_stale_aware_of_nodes();
          for (i$ = 0; i$ < number_of_nodes; ++i$) {
            i = i$;
            new_node_id = command_data.subarray(i * PUBLIC_KEY_LENGTH, (i + 1) * PUBLIC_KEY_LENGTH);
            if (are_arrays_equal(new_node_id, this._dht_public_key) || this._connected_nodes.has(new_node_id)) {
              continue;
            }
            if (this._aware_of_nodes.has(new_node_id) || this._aware_of_nodes.size < this._options['aware_of_nodes_limit']) {
              this._aware_of_nodes.set(new_node_id, +new Date);
              this['fire']('aware_of_nodes_count', this._aware_of_nodes.size);
            } else if (stale_aware_of_nodes.length) {
              stale_node_to_remove = pull_random_item_from_array(stale_aware_of_nodes);
              this._aware_of_nodes['delete'](stale_node_to_remove);
              this._aware_of_nodes.set(new_node_id, +new Date);
              this['fire']('aware_of_nodes_count', this._aware_of_nodes.size);
            } else {
              break;
            }
          }
          break;
        case UNCOMPRESSED_CORE_COMMAND_BOOTSTRAP_NODE:
          this._bootstrap_nodes.add(array2string(command_data));
          this._bootstrap_nodes_ids.add(peer_id);
        }
      }
      /**
       * @param {!Uint8Array}	peer_id
       * @param {number}		command			0..9
       * @param {!Uint8Array}	command_data
       */,
      _send_compressed_core_command: function(peer_id, command, command_data){
        this._send(peer_id, command, command_data);
      }
      /**
       * @param {!Uint8Array}	peer_id
       * @param {number}		command			0..9
       * @param {!Uint8Array}	command_data
       */,
      _send_dht_command: function(peer_id, command, command_data){
        this._send(peer_id, command + DHT_COMMANDS_OFFSET, command_data);
      }
      /**
       * @param {!Uint8Array}	peer_id
       * @param {!Uint8Array}	data
       */,
      _send_routing_command: function(peer_id, data){
        this._send(peer_id, ROUTING_COMMANDS, data);
      }
      /**
       * @param {!Uint8Array}	peer_id
       * @param {number}		command			0..234
       * @param {!Uint8Array}	command_data
       */,
      _send_uncompressed_core_command: function(peer_id, command, command_data){
        this._send(peer_id, command + UNCOMPRESSED_CORE_COMMANDS_OFFSET, command_data);
      }
      /**
       * @param {!Uint8Array}	node_id
       * @param {number}		command			0..255
       * @param {!Uint8Array}	command_data
       */,
      _send: function(node_id, command, command_data){
        var this$ = this;
        if (this._connected_nodes.has(node_id)) {
          this._update_connection_timeout(node_id, true);
          this._transport['send'](node_id, command, command_data);
          return;
        }
        function connected(new_node_id){
          if (!are_arrays_equal(node_id, new_node_id)) {
            return;
          }
          this$._update_connection_timeout(node_id, true);
          this$._transport['send'](node_id, command, command_data);
        }
        this._transport['on']('connected', connected);
        this._dht['lookup'](node_id, this._options['lookup_number']).then(function(){
          this$._transport['off']('connected', connected);
        })['catch'](function(){
          this$._transport['off']('connected', connected);
        });
      }
      /**
       * @param {!Uint8Array}	real_public_key
       * @param {!Uint8Array}	target_id
       * @param {number}		command			0..245
       * @param {!Uint8Array}	data
       */,
      _send_to_routing_node: function(real_public_key, target_id, command, data){
        var full_target_id, ref$, node_id, route_id;
        full_target_id = concat_arrays(real_public_key, target_id);
        if (!this._id_to_routing_path.has(full_target_id)) {
          return;
        }
        ref$ = this._id_to_routing_path.get(full_target_id), node_id = ref$[0], route_id = ref$[1];
        this._send_to_routing_path(node_id, route_id, command, data);
      }
      /**
       * @param {!Uint8Array} node_id
       * @param {!Uint8Array} route_id
       * @param {number}		command
       * @param {!Uint8Array}	data
       */,
      _send_to_routing_path: function(node_id, route_id, command, data){
        if (data.length === 0) {
          data = new Uint8Array(1);
        }
        return this._router['send_data'](node_id, route_id, command, data);
      }
      /**
       * @param {!Uint8Array} node_id
       * @param {!Uint8Array} route_id
       *
       * @return {boolean} `true` if ping was sent (not necessary delivered)
       */,
      _send_ping: function(node_id, route_id){
        var source_id;
        source_id = concat_arrays(node_id, route_id);
        if (this._pending_pings.has(source_id) || !this._routing_paths.has(source_id)) {
          return false;
        }
        this._send_to_routing_path(node_id, route_id, ROUTING_COMMAND_PING, empty_array);
        return true;
      }
      /**
       * @param {!Uint8Array}	node_id
       * @param {boolean}		send
       */,
      _update_connection_timeout: function(node_id, send){
        this._connections_timeouts.set(node_id, +new Date);
      }
      /**
       * Generate message with introduction nodes that can later be published by any node connected to DHT (typically other node than this for anonymity)
       *
       * @param {!Uint8Array}			real_public_key		Ed25519 public key (real one, different from supplied in DHT constructor)
       * @param {!Uint8Array}			real_private_key	Corresponding Ed25519 private key
       * @param {!Array<!Uint8Array>}	introduction_nodes	Array of public keys of introduction points
       *
       * @return {!Uint8Array}
       */,
      _generate_announcement_message: function(real_public_key, real_private_key, introduction_nodes){
        var time;
        time = parseInt(+new Date / 1000, 10);
        return concat_arrays(this._dht['make_mutable_value'](real_public_key, real_private_key, time, concat_arrays(introduction_nodes)));
      }
      /**
       * @param {!Uint8Array} message
       *
       * @return {Uint8Array} Public key if signature is correct, `null` otherwise
       */,
      _verify_announcement_message: function(message){
        var real_public_key, data, payload;
        real_public_key = message.subarray(0, PUBLIC_KEY_LENGTH);
        data = message.subarray(PUBLIC_KEY_LENGTH);
        payload = this._dht['verify_value'](real_public_key, data);
        if (!payload || payload[1].length % PUBLIC_KEY_LENGTH) {
          return null;
        } else {
          return real_public_key;
        }
      }
      /**
       * Publish message with introduction nodes (typically happens on different node than `_generate_announcement_message()`)
       *
       * @param {!Uint8Array} message
       */,
      _publish_announcement_message: function(message){
        var real_public_key, data;
        real_public_key = message.subarray(0, PUBLIC_KEY_LENGTH);
        data = message.subarray(PUBLIC_KEY_LENGTH);
        this._dht['put_value'](real_public_key, data, this._options['lookup_number']);
      }
      /**
       * Find nodes in DHT that are acting as introduction points for specified public key
       *
       * @param {!Uint8Array}	target_public_key
       *
       * @return {!Promise} Resolves with `!Array<!Uint8Array>`
       */,
      _find_introduction_nodes: function(target_public_key){
        return this._dht['get_value'](target_public_key, this._options['lookup_number']).then(function(introduction_nodes_bulk){
          var introduction_nodes, i$, to$, i;
          if (introduction_nodes_bulk.length % PUBLIC_KEY_LENGTH !== 0) {
            throw '';
          }
          introduction_nodes = [];
          for (i$ = 0, to$ = introduction_nodes_bulk.length / PUBLIC_KEY_LENGTH; i$ < to$; ++i$) {
            i = i$;
            introduction_nodes.push(introduction_nodes_bulk.subarray(i * PUBLIC_KEY_LENGTH, (i + 1) * PUBLIC_KEY_LENGTH));
          }
          return introduction_nodes;
        });
      },
      _peer_error: function(peer_id){
        this._dht['del_peer'](peer_id);
        this._transport['destroy_connection'](peer_id);
      },
      _peer_warning: function(peer_id){}
    };
    Core.prototype = Object.assign(Object.create(asyncEventer.prototype), Core.prototype);
    Object.defineProperty(Core.prototype, 'constructor', {
      value: Core
    });
    return {
      'ready': function(callback){
        detoxCrypto['ready'](function(){
          detoxDht['ready'](function(){
            detoxRouting['ready'](function(){
              callback();
            });
          });
        });
      }
      /**
       * Generate random seed that can be used as keypair seed
       *
       * @return {!Uint8Array} 32 bytes
       */,
      'generate_seed': function(){
        return random_bytes(PUBLIC_KEY_LENGTH);
      },
      'Core': Core
    };
  }
  if (typeof define === 'function' && define['amd']) {
    define(['@detox/crypto', '@detox/dht', '@detox/routing', '@detox/transport', '@detox/utils', 'fixed-size-multiplexer', 'async-eventer'], Wrapper);
  } else if (typeof exports === 'object') {
    module.exports = Wrapper(require('@detox/crypto'), require('@detox/dht'), require('@detox/routing'), require('@detox/transport'), require('@detox/utils'), require('fixed-size-multiplexer'), require('async-eventer'), require('node-fetch'));
  } else {
    this['detox_core'] = Wrapper(this['detox_crypto'], this['detox_dht'], this['detox_routing'], this['detox_transport'], this['detox_utils'], this['fixed_size_multiplexer'], this['async_eventer']);
  }
}).call(this);
