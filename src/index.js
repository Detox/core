// Generated by LiveScript 1.5.0
/**
 * @package Detox core
 * @author  Nazar Mokrynskyi <nazar@mokrynskyi.com>
 * @license 0BSD
 */
(function(){
  /*
   * Implements version 0.1.0 of the specification
   */
  var DHT_COMMAND_ROUTING, DHT_COMMAND_FORWARD_INTRODUCTION, DHT_COMMAND_GET_NODES_REQUEST, DHT_COMMAND_GET_NODES_RESPONSE, ROUTING_COMMAND_ANNOUNCE, ROUTING_COMMAND_FIND_INTRODUCTION_NODES_REQUEST, ROUTING_COMMAND_FIND_INTRODUCTION_NODES_RESPONSE, ROUTING_COMMAND_INITIALIZE_CONNECTION, ROUTING_COMMAND_INTRODUCTION, ROUTING_COMMAND_CONFIRM_CONNECTION, ROUTING_COMMAND_CONNECTED, ROUTING_COMMAND_DATA, ROUTING_COMMAND_PING, ID_LENGTH, SIGNATURE_LENGTH, HANDSHAKE_MESSAGE_LENGTH, MAC_LENGTH, APPLICATION_LENGTH, CONNECTION_TIMEOUT, ROUTING_PATH_SEGMENT_TIMEOUT, LAST_USED_TIMEOUT, ANNOUNCE_INTERVAL, STALE_AWARE_OF_NODE_TIMEOUT, AWARE_OF_NODES_LIMIT, GET_MORE_NODES_INTERVAL, CONNECTION_OK, CONNECTION_ERROR_NO_INTRODUCTION_NODES, CONNECTION_ERROR_CANT_FIND_INTRODUCTION_NODES, CONNECTION_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES, CONNECTION_ERROR_CANT_CONNECT_TO_RENDEZVOUS_POINT, CONNECTION_ERROR_OUT_OF_INTRODUCTION_NODES, CONNECTION_PROGRESS_CONNECTED_TO_RENDEZVOUS_NODE, CONNECTION_PROGRESS_FOUND_INTRODUCTION_NODES, CONNECTION_PROGRESS_INTRODUCTION_SENT, ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONNECTED, ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONFIRMED, ANNOUNCEMENT_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES;
  DHT_COMMAND_ROUTING = 0;
  DHT_COMMAND_FORWARD_INTRODUCTION = 1;
  DHT_COMMAND_GET_NODES_REQUEST = 2;
  DHT_COMMAND_GET_NODES_RESPONSE = 3;
  ROUTING_COMMAND_ANNOUNCE = 0;
  ROUTING_COMMAND_FIND_INTRODUCTION_NODES_REQUEST = 1;
  ROUTING_COMMAND_FIND_INTRODUCTION_NODES_RESPONSE = 2;
  ROUTING_COMMAND_INITIALIZE_CONNECTION = 3;
  ROUTING_COMMAND_INTRODUCTION = 4;
  ROUTING_COMMAND_CONFIRM_CONNECTION = 5;
  ROUTING_COMMAND_CONNECTED = 6;
  ROUTING_COMMAND_DATA = 7;
  ROUTING_COMMAND_PING = 8;
  ID_LENGTH = 32;
  SIGNATURE_LENGTH = 64;
  HANDSHAKE_MESSAGE_LENGTH = 48;
  MAC_LENGTH = 16;
  APPLICATION_LENGTH = 64;
  CONNECTION_TIMEOUT = 30;
  ROUTING_PATH_SEGMENT_TIMEOUT = 10;
  LAST_USED_TIMEOUT = 60;
  ANNOUNCE_INTERVAL = 30 * 60;
  STALE_AWARE_OF_NODE_TIMEOUT = 5 * 60;
  AWARE_OF_NODES_LIMIT = 1000;
  GET_MORE_NODES_INTERVAL = 30;
  CONNECTION_OK = 0;
  CONNECTION_ERROR_NO_INTRODUCTION_NODES = 1;
  CONNECTION_ERROR_CANT_FIND_INTRODUCTION_NODES = 2;
  CONNECTION_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES = 3;
  CONNECTION_ERROR_CANT_CONNECT_TO_RENDEZVOUS_POINT = 4;
  CONNECTION_ERROR_OUT_OF_INTRODUCTION_NODES = 5;
  CONNECTION_PROGRESS_CONNECTED_TO_RENDEZVOUS_NODE = 0;
  CONNECTION_PROGRESS_FOUND_INTRODUCTION_NODES = 1;
  CONNECTION_PROGRESS_INTRODUCTION_SENT = 2;
  ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONNECTED = 0;
  ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONFIRMED = 1;
  ANNOUNCEMENT_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES = 2;
  /**
   * @param {number}				code
   * @param {!Uint8Array}			target_id
   * @param {!Array<!Uint8Array>}	nodes
   *
   * @return {!Uint8Array}
   */
  function compose_find_introduction_nodes_response(code, target_id, nodes){
    var x$, result, i$, len$, i, node;
    x$ = result = new Uint8Array(1 + ID_LENGTH + nodes.length * ID_LENGTH);
    x$.set([code]);
    x$.set(target_id, 1);
    for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
      i = i$;
      node = nodes[i$];
      result.set(node, 1 + ID_LENGTH + i * ID_LENGTH);
    }
    return result;
  }
  /**
   * @param {!Uint8Array} data
   *
   * @return {!Array} [code, target_id, nodes]
   */
  function parse_find_introduction_nodes_response(data){
    var code, target_id, nodes, i$, to$, i;
    code = data[0];
    target_id = data.subarray(1, 1 + ID_LENGTH);
    nodes = [];
    data = data.subarray(1 + ID_LENGTH);
    for (i$ = 0, to$ = data.length / ID_LENGTH; i$ < to$; ++i$) {
      i = i$;
      nodes.push(data.subarray(i * ID_LENGTH, (i + 1) * ID_LENGTH));
    }
    return [code, target_id, nodes];
  }
  /**
   * @param {!Uint8Array} target_id
   * @param {!Uint8Array} rendezvous_node
   * @param {!Uint8Array} rendezvous_token
   * @param {!Uint8Array} handshake_message
   * @param {!Uint8Array} application
   * @param {!Uint8Array} secret
   *
   * @return {!Uint8Array}
   */
  function compose_introduction_payload(target_id, rendezvous_node, rendezvous_token, handshake_message, application, secret){
    var x$;
    x$ = new Uint8Array(ID_LENGTH * 3 + HANDSHAKE_MESSAGE_LENGTH + APPLICATION_LENGTH + ID_LENGTH);
    x$.set(target_id);
    x$.set(rendezvous_node, ID_LENGTH);
    x$.set(rendezvous_token, ID_LENGTH * 2);
    x$.set(handshake_message, ID_LENGTH * 3);
    x$.set(application, ID_LENGTH * 3 + HANDSHAKE_MESSAGE_LENGTH);
    x$.set(secret, ID_LENGTH * 3 + HANDSHAKE_MESSAGE_LENGTH + APPLICATION_LENGTH);
    return x$;
  }
  /**
   * @param {!Uint8Array} introduction_payload
   *
   * @return {!Array<!Uint8Array>} [target_id, rendezvous_node, rendezvous_token, handshake_message, application, secret]
   */
  function parse_introduction_payload(introduction_payload){
    var target_id, rendezvous_node, rendezvous_token, handshake_message, application, secret;
    target_id = introduction_payload.subarray(0, ID_LENGTH);
    rendezvous_node = introduction_payload.subarray(ID_LENGTH, ID_LENGTH * 2);
    rendezvous_token = introduction_payload.subarray(ID_LENGTH * 2, ID_LENGTH * 3);
    handshake_message = introduction_payload.subarray(ID_LENGTH * 3, ID_LENGTH * 3 + HANDSHAKE_MESSAGE_LENGTH);
    application = introduction_payload.subarray(ID_LENGTH * 3 + HANDSHAKE_MESSAGE_LENGTH, ID_LENGTH * 3 + HANDSHAKE_MESSAGE_LENGTH + APPLICATION_LENGTH);
    secret = introduction_payload.subarray(ID_LENGTH * 3 + HANDSHAKE_MESSAGE_LENGTH + APPLICATION_LENGTH, ID_LENGTH * 3 + HANDSHAKE_MESSAGE_LENGTH + APPLICATION_LENGTH + ID_LENGTH);
    return [target_id, rendezvous_node, rendezvous_token, handshake_message, application, secret];
  }
  /**
   * @param {!Uint8Array} rendezvous_token
   * @param {!Uint8Array} introduction_node
   * @param {!Uint8Array} target_id
   * @param {!Uint8Array} introduction_message
   *
   * @return {!Uint8Array}
   */
  function compose_initialize_connection_data(rendezvous_token, introduction_node, target_id, introduction_message){
    var x$;
    x$ = new Uint8Array(ID_LENGTH * 3 + introduction_message.length);
    x$.set(rendezvous_token);
    x$.set(introduction_node, ID_LENGTH);
    x$.set(target_id, ID_LENGTH * 2);
    x$.set(introduction_message, ID_LENGTH * 3);
    return x$;
  }
  /**
   * @param {!Uint8Array} message
   *
   * @return {!Array<!Uint8Array>} [rendezvous_token, introduction_node, target_id, introduction_message]
   */
  function parse_initialize_connection_data(message){
    var rendezvous_token, introduction_node, target_id, introduction_message;
    rendezvous_token = message.subarray(0, ID_LENGTH);
    introduction_node = message.subarray(ID_LENGTH, ID_LENGTH * 2);
    target_id = message.subarray(ID_LENGTH * 2, ID_LENGTH * 3);
    introduction_message = message.subarray(ID_LENGTH * 3);
    return [rendezvous_token, introduction_node, target_id, introduction_message];
  }
  /**
   * @param {!Uint8Array} signature
   * @param {!Uint8Array} rendezvous_token
   * @param {!Uint8Array} handshake_message
   *
   * @return {!Uint8Array}
   */
  function compose_confirm_connection_data(signature, rendezvous_token, handshake_message){
    var x$;
    x$ = new Uint8Array(SIGNATURE_LENGTH + ID_LENGTH + HANDSHAKE_MESSAGE_LENGTH);
    x$.set(signature);
    x$.set(rendezvous_token, SIGNATURE_LENGTH);
    x$.set(handshake_message, SIGNATURE_LENGTH + ID_LENGTH);
    return x$;
  }
  /**
   * @param {!Uint8Array} message
   *
   * @return {!Array<!Uint8Array>} [signature, rendezvous_token, handshake_message]
   */
  function parse_confirm_connection_data(message){
    var signature, rendezvous_token, handshake_message;
    signature = message.subarray(0, SIGNATURE_LENGTH);
    rendezvous_token = message.subarray(SIGNATURE_LENGTH, SIGNATURE_LENGTH + ID_LENGTH);
    handshake_message = message.subarray(SIGNATURE_LENGTH + ID_LENGTH);
    return [signature, rendezvous_token, handshake_message];
  }
  /**
   * @param {!Uint8Array} target_id
   * @param {!Uint8Array} introduction_message
   *
   * @return {!Uint8Array}
   */
  function compose_introduce_to_data(target_id, introduction_message){
    var x$;
    x$ = new Uint8Array(ID_LENGTH + introduction_message.length);
    x$.set(target_id);
    x$.set(introduction_message, ID_LENGTH);
    return x$;
  }
  /**
   * @param {!Uint8Array} message
   *
   * @return {!Array<!Uint8Array>} [target_id, introduction_message]
   */
  function parse_introduce_to_data(message){
    var target_id, introduction_message;
    target_id = message.subarray(0, ID_LENGTH);
    introduction_message = message.subarray(ID_LENGTH);
    return [target_id, introduction_message];
  }
  function Wrapper(detoxCrypto, detoxTransport, detoxUtils, fixedSizeMultiplexer, asyncEventer){
    var random_bytes, random_int, pull_random_item_from_array, are_arrays_equal, concat_arrays, timeoutSet, intervalSet, error_handler, ArrayMap, ArraySet;
    random_bytes = detoxUtils['random_bytes'];
    random_int = detoxUtils['random_int'];
    pull_random_item_from_array = detoxUtils['pull_random_item_from_array'];
    are_arrays_equal = detoxUtils['are_arrays_equal'];
    concat_arrays = detoxUtils['concat_arrays'];
    timeoutSet = detoxUtils['timeoutSet'];
    intervalSet = detoxUtils['intervalSet'];
    error_handler = detoxUtils['error_handler'];
    ArrayMap = detoxUtils['ArrayMap'];
    ArraySet = detoxUtils['ArraySet'];
    /**
     * @constructor
     *
     * @param {!Uint8Array}		dht_key_seed			Seed used to generate temporary DHT keypair
     * @param {!Array<!Object>}	bootstrap_nodes
     * @param {!Array<!Object>}	ice_servers
     * @param {number}			packets_per_second		Each packet send in each direction has exactly the same size and packets are sent at fixed rate (>= 1)
     * @param {number}			bucket_size
     * @param {number}			max_pending_segments	How much routing segments can be in pending state per one address
     *
     * @return {!Core}
     *
     * @throws {Error}
     */
    function Core(dht_key_seed, bootstrap_nodes, ice_servers, packets_per_second, bucket_size, max_pending_segments){
      var this$ = this;
      packets_per_second == null && (packets_per_second = 1);
      bucket_size == null && (bucket_size = 2);
      max_pending_segments == null && (max_pending_segments = 10);
      if (!(this instanceof Core)) {
        return new Core(dht_key_seed, bootstrap_nodes, ice_servers, packets_per_second, bucket_size, max_pending_segments);
      }
      asyncEventer.call(this);
      this._real_keypairs = ArrayMap();
      this._dht_keypair = detoxCrypto['create_keypair'](dht_key_seed);
      this._max_data_size = detoxTransport['MAX_DATA_SIZE'];
      this._connected_nodes = ArraySet();
      this._aware_of_nodes = ArrayMap();
      this._get_nodes_requested = ArraySet();
      this._routing_paths = ArrayMap();
      this._id_to_routing_path = ArrayMap();
      this._routing_path_to_id = ArrayMap();
      this._used_tags = ArrayMap();
      this._connections_timeouts = ArrayMap();
      this._routes_timeouts = ArrayMap();
      this._pending_connection = ArrayMap();
      this._announcements_from = ArrayMap();
      this._forwarding_mapping = ArrayMap();
      this._pending_pings = ArraySet();
      this._encryptor_instances = ArrayMap();
      this._multiplexers = ArrayMap();
      this._demultiplexers = ArrayMap();
      this._pending_sending = ArrayMap();
      this._cleanup_interval = intervalSet(LAST_USED_TIMEOUT, function(){
        var unused_older_than;
        unused_older_than = +new Date - LAST_USED_TIMEOUT * 1000;
        this$._routes_timeouts.forEach(function(last_updated, source_id){
          var ref$, node_id, route_id;
          if (last_updated < unused_older_than) {
            if (this$._routing_paths.has(source_id)) {
              ref$ = this$._routing_paths.get(source_id), node_id = ref$[0], route_id = ref$[1];
              this$._unregister_routing_path(node_id, route_id);
            }
            this$._routes_timeouts['delete'](source_id);
          }
        });
        this$._connections_timeouts.forEach(function(last_updated, node_id){
          if (last_updated < unused_older_than) {
            this$._del_used_tag(node_id);
            this$._connections_timeouts['delete'](node_id);
          }
        });
      });
      this._keep_announce_routes_interval = intervalSet(LAST_USED_TIMEOUT, function(){
        this$._real_keypairs.forEach(function(arg$, real_public_key){
          var real_keypair, number_of_introduction_nodes, number_of_intermediate_nodes, announced_to, last_announcement, reannounce_if_older_than;
          real_keypair = arg$[0], number_of_introduction_nodes = arg$[1], number_of_intermediate_nodes = arg$[2], announced_to = arg$[3], last_announcement = arg$[4];
          if (announced_to.size < number_of_introduction_nodes && last_announcement) {
            reannounce_if_older_than = +new Date - CONNECTION_TIMEOUT * 3;
            if (last_announcement < reannounce_if_older_than) {
              this$._announce(real_public_key);
            }
          }
          announced_to.forEach(function(introduction_node){
            var full_introduction_node_id, ref$, node_id, route_id, source_id;
            full_introduction_node_id = concat_arrays([real_public_key, introduction_node]);
            ref$ = this$._id_to_routing_path.get(full_introduction_node_id), node_id = ref$[0], route_id = ref$[1];
            if (this$._send_ping(node_id, route_id)) {
              source_id = concat_arrays([node_id, route_id]);
              this$._pending_pings.add(source_id);
            }
          });
        });
      });
      this._get_more_nodes_interval = intervalSet(GET_MORE_NODES_INTERVAL, function(){
        if (this$._more_nodes_needed()) {
          this$._get_more_nodes();
        }
      });
      this._dht = detoxTransport['DHT'](this._dht_keypair['ed25519']['public'], this._dht_keypair['ed25519']['private'], bootstrap_nodes, ice_servers, packets_per_second, bucket_size)['on']('node_connected', function(node_id){
        this$._connected_nodes.add(node_id);
        if (this$._more_nodes_needed()) {
          this$._get_more_nodes_from(node_id);
        }
      })['on']('node_disconnected', function(node_id){
        this$._connected_nodes['delete'](node_id);
        this$._get_nodes_requested['delete'](node_id);
      })['on']('data', function(node_id, command, data){
        var ref$, target_id, introduction_message, target_node_id, target_route_id, nodes, i$, len$, i, node, number_of_nodes, stale_aware_of_nodes, new_node_id, stale_node_to_remove;
        switch (command) {
        case DHT_COMMAND_ROUTING:
          this$._router['process_packet'](node_id, data);
          break;
        case DHT_COMMAND_FORWARD_INTRODUCTION:
          if (this$._bootstrap_node) {
            return;
          }
          ref$ = parse_introduce_to_data(data), target_id = ref$[0], introduction_message = ref$[1];
          if (!this$._announcements_from.has(target_id)) {
            return;
          }
          ref$ = this$._announcements_from.get(target_id), target_node_id = ref$[0], target_route_id = ref$[1];
          this$._router['send_data'](target_node_id, target_route_id, ROUTING_COMMAND_INTRODUCTION, introduction_message);
          break;
        case DHT_COMMAND_GET_NODES_REQUEST:
          nodes = this$._pick_random_connected_nodes(7) || [];
          nodes = nodes.concat(this$._pick_random_aware_of_nodes(10 - nodes.length) || []);
          data = new Uint8Array(nodes.length * ID_LENGTH);
          for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
            i = i$;
            node = nodes[i$];
            data.set(node, i * ID_LENGTH);
          }
          this$._send_to_dht_node(node_id, DHT_COMMAND_GET_NODES_RESPONSE, data);
          break;
        case DHT_COMMAND_GET_NODES_RESPONSE:
          if (!this$._get_nodes_requested.has(node_id)) {
            return;
          }
          this$._get_nodes_requested['delete'](node_id);
          if (!data.length || data.length % ID_LENGTH !== 0) {
            return;
          }
          number_of_nodes = data.length / ID_LENGTH;
          stale_aware_of_nodes = this$._get_stale_aware_of_nodes();
          for (i$ = 0; i$ < number_of_nodes; ++i$) {
            i = i$;
            new_node_id = data.subarray(i * ID_LENGTH, (i + 1) * ID_LENGTH);
            if (are_arrays_equal(new_node_id, this$._dht_keypair['ed25519']['public']) || this$._connected_nodes.has(new_node_id)) {
              continue;
            }
            if (this$._aware_of_nodes.has(new_node_id) || this$._aware_of_nodes.size < AWARE_OF_NODES_LIMIT) {
              this$._aware_of_nodes.set(new_node_id, +new Date);
            } else if (stale_aware_of_nodes.length) {
              stale_node_to_remove = pull_random_item_from_array(stale_aware_of_nodes);
              this$._aware_of_nodes['delete'](stale_node_to_remove);
              this$._aware_of_nodes.set(new_node_id, +new Date);
            } else {
              break;
            }
          }
        }
      })['on']('ready', function(){
        this$._dht['lookup'](random_bytes(ID_LENGTH));
        this$._dht['lookup'](random_bytes(ID_LENGTH));
        this$._dht['lookup'](random_bytes(ID_LENGTH));
        this$['fire']('ready');
      });
      this._router = detoxTransport['Router'](this._dht_keypair['x25519']['private'], max_pending_segments)['on']('activity', function(node_id, route_id){
        var source_id;
        source_id = concat_arrays([node_id, route_id]);
        if (!this$._routing_paths.has(source_id)) {
          this$._routing_paths.set(source_id, [node_id, route_id]);
        }
        this$._update_connection_timeout(node_id);
        this$._routes_timeouts.set(source_id, +new Date);
      })['on']('send', function(node_id, data){
        this$._send_to_dht_node(node_id, DHT_COMMAND_ROUTING, data);
      })['on']('data', function(node_id, route_id, command, data){
        var source_id, public_key, announce_interval, target_id, send_response, ref$, rendezvous_token, introduction_node, introduction_message, connection_timeout, signature, handshake_message, target_node_id, target_route_id, target_source_id, real_public_key, real_keypair, announced_to, introduction_message_decrypted, introduction_payload, rendezvous_node, application, secret, x$, for_signature, full_target_id, error, encryptor_instance, demultiplexer, data_decrypted, data_with_header;
        source_id = concat_arrays([node_id, route_id]);
        switch (command) {
        case ROUTING_COMMAND_ANNOUNCE:
          if (this$._bootstrap_node) {
            return;
          }
          public_key = this$._dht['verify_announcement_message'](data);
          if (!public_key) {
            return;
          }
          if (this$._announcements_from.has(public_key)) {
            clearInterval(this$._announcements_from.get(public_key)[2]);
          }
          announce_interval = intervalSet(ANNOUNCE_INTERVAL, function(){
            if (!this$._routing_paths.has(source_id)) {
              return;
            }
            this$._dht['publish_announcement_message'](data);
          });
          this$._announcements_from.set(public_key, [node_id, route_id, announce_interval]);
          this$._dht['publish_announcement_message'](data);
          break;
        case ROUTING_COMMAND_FIND_INTRODUCTION_NODES_REQUEST:
          if (this$._bootstrap_node) {
            return;
          }
          target_id = data;
          if (target_id.length !== ID_LENGTH) {
            return;
          }
          /**
           * @param {number}				code
           * @param {!Array<!Uint8Array>}	nodes
           */
          send_response = function(code, nodes){
            var data;
            data = compose_find_introduction_nodes_response(code, target_id, nodes);
            this$._router['send_data'](node_id, route_id, ROUTING_COMMAND_FIND_INTRODUCTION_NODES_RESPONSE, data);
          };
          this$._dht['find_introduction_nodes'](target_id, function(introduction_nodes){
            if (!introduction_nodes.length) {
              send_response(CONNECTION_ERROR_NO_INTRODUCTION_NODES, []);
            } else {
              send_response(CONNECTION_OK, introduction_nodes);
            }
          }, function(){
            send_response(CONNECTION_ERROR_NO_INTRODUCTION_NODES, []);
          });
          break;
        case ROUTING_COMMAND_INITIALIZE_CONNECTION:
          if (this$._bootstrap_node) {
            return;
          }
          ref$ = parse_initialize_connection_data(data), rendezvous_token = ref$[0], introduction_node = ref$[1], target_id = ref$[2], introduction_message = ref$[3];
          if (this$._pending_connection.has(rendezvous_token)) {
            return;
          }
          connection_timeout = timeoutSet(CONNECTION_TIMEOUT, function(){
            this$._pending_connection['delete'](rendezvous_token);
          });
          this$._pending_connection.set(rendezvous_token, [node_id, route_id, target_id, connection_timeout]);
          this$._send_to_dht_node(introduction_node, DHT_COMMAND_FORWARD_INTRODUCTION, compose_introduce_to_data(target_id, introduction_message));
          break;
        case ROUTING_COMMAND_CONFIRM_CONNECTION:
          ref$ = parse_confirm_connection_data(data), signature = ref$[0], rendezvous_token = ref$[1], handshake_message = ref$[2];
          if (!this$._pending_connection.has(rendezvous_token)) {
            return;
          }
          ref$ = this$._pending_connection.get(rendezvous_token), target_node_id = ref$[0], target_route_id = ref$[1], target_id = ref$[2], connection_timeout = ref$[3];
          if (!detoxCrypto['verify'](signature, rendezvous_token, target_id)) {
            return;
          }
          this$._pending_connection['delete'](rendezvous_token);
          clearTimeout(connection_timeout);
          this$._router['send_data'](target_node_id, target_route_id, ROUTING_COMMAND_CONNECTED, data);
          target_source_id = concat_arrays([target_node_id, target_route_id]);
          this$._forwarding_mapping.set(source_id, [target_node_id, target_route_id]);
          this$._forwarding_mapping.set(target_source_id, [node_id, route_id]);
          break;
        case ROUTING_COMMAND_INTRODUCTION:
          if (!this$._routing_path_to_id.has(source_id)) {
            return;
          }
          ref$ = this$._routing_path_to_id.get(source_id), real_public_key = ref$[0], introduction_node = ref$[1];
          if (!this$._real_keypairs.has(real_public_key)) {
            return;
          }
          ref$ = this$._real_keypairs.get(real_public_key), real_keypair = ref$[0], announced_to = ref$[3];
          if (!announced_to.has(introduction_node)) {
            return;
          }
          try {
            introduction_message_decrypted = detoxCrypto['one_way_decrypt'](real_keypair['x25519']['private'], data);
            signature = introduction_message_decrypted.subarray(0, SIGNATURE_LENGTH);
            introduction_payload = introduction_message_decrypted.subarray(SIGNATURE_LENGTH);
            ref$ = parse_introduction_payload(introduction_payload), target_id = ref$[0], rendezvous_node = ref$[1], rendezvous_token = ref$[2], handshake_message = ref$[3], application = ref$[4], secret = ref$[5];
            x$ = for_signature = new Uint8Array(ID_LENGTH + introduction_payload.length);
            x$.set(introduction_node);
            x$.set(introduction_payload, ID_LENGTH);
            if (!detoxCrypto['verify'](signature, for_signature, target_id)) {
              return;
            }
            full_target_id = concat_arrays([real_public_key, target_id]);
            if (this$._id_to_routing_path.has(full_target_id)) {
              return;
            }
            data = {
              'real_public_key': real_public_key,
              'target_id': target_id,
              'secret': secret,
              'application': application,
              'number_of_intermediate_nodes': null
            };
            this$['fire']('introduction', data).then(function(){
              var number_of_intermediate_nodes, nodes, first_node;
              number_of_intermediate_nodes = data['number_of_intermediate_nodes'];
              if (!number_of_intermediate_nodes) {
                throw new Error('Direct connections are not yet supported');
              }
              nodes = this$._pick_nodes_for_routing_path(number_of_intermediate_nodes, [rendezvous_node]);
              if (!nodes) {
                return;
              }
              nodes.push(rendezvous_node);
              first_node = nodes[0];
              this$._router['construct_routing_path'](nodes).then(function(route_id){
                var encryptor_instance, response_handshake_message, signature;
                encryptor_instance = detoxCrypto['Encryptor'](false, real_keypair['x25519']['private']);
                encryptor_instance['put_handshake_message'](handshake_message);
                response_handshake_message = encryptor_instance['get_handshake_message']();
                this$._encryptor_instances.set(full_target_id, encryptor_instance);
                this$._register_routing_path(real_keypair['ed25519']['public'], target_id, first_node, route_id);
                signature = detoxCrypto['sign'](rendezvous_token, real_keypair['ed25519']['public'], real_keypair['ed25519']['private']);
                this$._send_to_routing_node(real_public_key, target_id, ROUTING_COMMAND_CONFIRM_CONNECTION, compose_confirm_connection_data(signature, rendezvous_token, response_handshake_message));
              })['catch'](function(error){
                error_handler(error);
              });
            })['catch'](function(error){
              error_handler(error);
            });
          } catch (e$) {
            error = e$;
            error_handler(error);
          }
          break;
        case ROUTING_COMMAND_DATA:
          if (this$._forwarding_mapping.has(source_id)) {
            ref$ = this$._forwarding_mapping.get(source_id), target_node_id = ref$[0], target_route_id = ref$[1];
            this$._router['send_data'](target_node_id, target_route_id, ROUTING_COMMAND_DATA, data);
          } else if (this$._routing_path_to_id.has(source_id)) {
            ref$ = this$._routing_path_to_id.get(source_id), real_public_key = ref$[0], target_id = ref$[1];
            full_target_id = concat_arrays([real_public_key, target_id]);
            encryptor_instance = this$._encryptor_instances.get(full_target_id);
            if (!encryptor_instance) {
              return;
            }
            demultiplexer = this$._demultiplexers.get(full_target_id);
            if (!demultiplexer) {
              return;
            }
            data_decrypted = encryptor_instance['decrypt'](data);
            demultiplexer['feed'](data_decrypted);
            if (demultiplexer['have_more_data']()) {
              data_with_header = demultiplexer['get_data']();
              command = data_with_header[0];
              this$['fire']('data', real_public_key, target_id, command, data_with_header.subarray(1));
            }
          }
          break;
        case ROUTING_COMMAND_PING:
          if (this$._routing_path_to_id.has(source_id)) {
            if (this$._pending_pings.has(source_id)) {
              this$._pending_pings['delete'](source_id);
              return;
            }
          }
          this$._send_ping(node_id, route_id);
        }
      });
      this._max_packet_data_size = this._router['get_max_packet_data_size']() - MAC_LENGTH;
    }
    Core['CONNECTION_ERROR_CANT_FIND_INTRODUCTION_NODES'] = CONNECTION_ERROR_CANT_FIND_INTRODUCTION_NODES;
    Core['CONNECTION_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES'] = CONNECTION_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES;
    Core['CONNECTION_ERROR_NO_INTRODUCTION_NODES'] = CONNECTION_ERROR_NO_INTRODUCTION_NODES;
    Core['CONNECTION_ERROR_CANT_CONNECT_TO_RENDEZVOUS_POINT'] = CONNECTION_ERROR_CANT_CONNECT_TO_RENDEZVOUS_POINT;
    Core['CONNECTION_ERROR_OUT_OF_INTRODUCTION_NODES'] = CONNECTION_ERROR_OUT_OF_INTRODUCTION_NODES;
    Core['CONNECTION_PROGRESS_CONNECTED_TO_RENDEZVOUS_NODE'] = CONNECTION_PROGRESS_CONNECTED_TO_RENDEZVOUS_NODE;
    Core['CONNECTION_PROGRESS_FOUND_INTRODUCTION_NODES'] = CONNECTION_PROGRESS_FOUND_INTRODUCTION_NODES;
    Core['CONNECTION_PROGRESS_INTRODUCTION_SENT'] = CONNECTION_PROGRESS_INTRODUCTION_SENT;
    Core['ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONNECTED'] = ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONNECTED;
    Core['ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONFIRMED'] = ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONFIRMED;
    Core['ANNOUNCEMENT_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES'] = ANNOUNCEMENT_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES;
    Core.prototype = {
      /**
       * Start WebSocket server listening on specified ip:port, so that current node will be capable of acting as bootstrap node for other users
       *
       * @param {string}	ip
       * @param {number}	port
       */
      'start_bootstrap_node': function(ip, port){
        this._dht['start_bootstrap_node'](ip, port);
        this._bootstrap_node = true;
      }
      /**
       * Get an array of bootstrap nodes obtained during DHT operation in the same format as `bootstrap_nodes` argument in constructor
       *
       * @return {!Array<!Object>} Each element is an object with keys `host`, `port` and `node_id`
       */,
      'get_bootstrap_nodes': function(){
        return this._dht['get_bootstrap_nodes']();
      }
      /**
       * @param {!Uint8Array}	real_key_seed					Seed used to generate real long-term keypair
       * @param {number}		number_of_introduction_nodes
       * @param {number}		number_of_intermediate_nodes	How many hops should be made until introduction node (not including it)
       *
       * @return {Uint8Array} Real public key or `null` in case of failure
       */,
      'announce': function(real_key_seed, number_of_introduction_nodes, number_of_intermediate_nodes){
        var real_keypair, real_public_key;
        real_keypair = detoxCrypto['create_keypair'](real_key_seed);
        real_public_key = real_keypair['ed25519']['public'];
        if (this._real_keypairs.has(real_public_key)) {
          return null;
        }
        this._real_keypairs.set(real_public_key, [real_keypair, number_of_introduction_nodes, number_of_intermediate_nodes, ArraySet()]);
        this._announce(real_public_key);
        return real_public_key;
      }
      /**
       * @param {!Uint8Array} real_public_key
       */,
      _announce: function(real_public_key){
        var ref$, real_keypair, number_of_introduction_nodes, number_of_intermediate_nodes, announced_to, old_introduction_nodes, introduction_nodes, introductions_pending, introduction_nodes_confirmed, i$, len$, this$ = this;
        ref$ = this._real_keypairs.get(real_public_key), real_keypair = ref$[0], number_of_introduction_nodes = ref$[1], number_of_intermediate_nodes = ref$[2], announced_to = ref$[3];
        old_introduction_nodes = [];
        announced_to.forEach(function(introduction_node){
          old_introduction_nodes.push(introduction_node);
        });
        number_of_introduction_nodes = number_of_introduction_nodes - old_introduction_nodes.length;
        if (!number_of_introduction_nodes) {
          return;
        }
        this._update_last_announcement(real_public_key, +new Date);
        introduction_nodes = this._pick_random_aware_of_nodes(number_of_introduction_nodes, old_introduction_nodes);
        if (!introduction_nodes) {
          this._update_last_announcement(real_public_key, 1);
          this['fire']('announcement_failed', real_public_key, ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONNECTED);
          return;
        }
        introductions_pending = number_of_introduction_nodes;
        introduction_nodes_confirmed = [];
        /**
         * @param {!Uint8Array=} introduction_node
         */
        function announced(introduction_node){
          var announcement_message, i$, len$;
          if (introduction_node) {
            introduction_nodes_confirmed.push(introduction_node);
          }
          --introductions_pending;
          if (introductions_pending) {
            return;
          }
          if (!introduction_nodes_confirmed.length) {
            this$._update_last_announcement(real_public_key, 1);
            this$['fire']('announcement_failed', real_public_key, ANNOUNCEMENT_ERROR_NO_INTRODUCTION_NODES_CONFIRMED);
            return;
          }
          introduction_nodes_confirmed = introduction_nodes_confirmed.concat(old_introduction_nodes);
          announcement_message = this$._dht['generate_announcement_message'](real_public_key, real_keypair['ed25519']['private'], introduction_nodes_confirmed);
          for (i$ = 0, len$ = introduction_nodes_confirmed.length; i$ < len$; ++i$) {
            introduction_node = introduction_nodes_confirmed[i$];
            this$._send_to_routing_node(real_public_key, introduction_node, ROUTING_COMMAND_ANNOUNCE, announcement_message);
          }
          this$['fire']('announced', real_public_key);
        }
        for (i$ = 0, len$ = introduction_nodes.length; i$ < len$; ++i$) {
          (fn$.call(this, introduction_nodes[i$]));
        }
        function fn$(introduction_node){
          var nodes, first_node, this$ = this;
          nodes = this._pick_nodes_for_routing_path(number_of_intermediate_nodes, introduction_nodes.concat(old_introduction_nodes));
          if (!nodes) {
            this['fire']('announcement_failed', real_public_key, ANNOUNCEMENT_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES);
            return;
          }
          nodes.push(introduction_node);
          first_node = nodes[0];
          this._router['construct_routing_path'](nodes).then(function(route_id){
            this$._register_routing_path(real_public_key, introduction_node, first_node, route_id);
            announced_to.add(introduction_node);
            announced(introduction_node);
          })['catch'](function(error){
            error_handler(error);
            announced();
          });
        }
      }
      /**
       * @param {!Uint8Array}	real_public_key
       * @param {number}		value
       */,
      _update_last_announcement: function(real_public_key, value){
        this._real_keypairs.get(real_public_key)[4] = value;
      }
      /**
       * @param {!Uint8Array}	real_key_seed					Seed used to generate real long-term keypair
       * @param {!Uint8Array}	target_id						Real Ed25519 pubic key of interested node
       * @param {!Uint8Array}	application						Up to 64 bytes
       * @param {!Uint8Array}	secret							Up to 32 bytes
       * @param {number}		number_of_intermediate_nodes	How many hops should be made until rendezvous node (including it)
       *
       * @return {Uint8Array} Real public key or `null` in case of failure
       */,
      'connect_to': function(real_key_seed, target_id, application, secret, number_of_intermediate_nodes){
        var real_keypair, real_public_key, full_target_id, nodes, first_node, rendezvous_node, this$ = this;
        if (!number_of_intermediate_nodes) {
          throw new Error('Direct connections are not yet supported');
        }
        real_keypair = detoxCrypto['create_keypair'](real_key_seed);
        real_public_key = real_keypair['ed25519']['public'];
        full_target_id = concat_arrays([real_public_key, target_id]);
        if (this._id_to_routing_path.has(full_target_id)) {
          return null;
        }
        nodes = this._pick_nodes_for_routing_path(number_of_intermediate_nodes);
        if (!nodes) {
          this['fire']('connection_failed', real_public_key, target_id, CONNECTION_ERROR_NOT_ENOUGH_INTERMEDIATE_NODES);
          return null;
        }
        first_node = nodes[0];
        rendezvous_node = nodes[nodes.length - 1];
        this._router['construct_routing_path'](nodes).then(function(route_id){
          var find_introduction_nodes_timeout;
          this$['fire']('connection_progress', real_public_key, target_id, CONNECTION_PROGRESS_CONNECTED_TO_RENDEZVOUS_NODE);
          function found_introduction_nodes(new_node_id, new_route_id, command, data){
            var ref$, code, introduction_target_id, introduction_nodes;
            if (!(are_arrays_equal(first_node, new_node_id) && are_arrays_equal(route_id, new_route_id) && command === ROUTING_COMMAND_FIND_INTRODUCTION_NODES_RESPONSE)) {
              return;
            }
            ref$ = parse_find_introduction_nodes_response(data), code = ref$[0], introduction_target_id = ref$[1], introduction_nodes = ref$[2];
            if (!are_arrays_equal(target_id, introduction_target_id)) {
              return;
            }
            clearTimeout(find_introduction_nodes_timeout);
            if (code !== CONNECTION_OK) {
              this$['fire']('connection_failed', real_public_key, target_id, code);
              return;
            }
            this$['fire']('connection_progress', real_public_key, target_id, CONNECTION_PROGRESS_FOUND_INTRODUCTION_NODES);
            function try_to_introduce(){
              var introduction_node, rendezvous_token, x25519_public_key, encryptor_instance, handshake_message, introduction_payload, x$, for_signature, signature, y$, introduction_message, introduction_message_encrypted, path_confirmation_timeout;
              if (!introduction_nodes.length) {
                this$['fire']('connection_failed', real_public_key, target_id, CONNECTION_ERROR_OUT_OF_INTRODUCTION_NODES);
                return;
              }
              introduction_node = pull_random_item_from_array(introduction_nodes);
              rendezvous_token = random_bytes(ID_LENGTH);
              x25519_public_key = detoxCrypto['convert_public_key'](target_id);
              encryptor_instance = detoxCrypto['Encryptor'](true, x25519_public_key);
              handshake_message = encryptor_instance['get_handshake_message']();
              introduction_payload = compose_introduction_payload(real_public_key, rendezvous_node, rendezvous_token, handshake_message, application, secret);
              x$ = for_signature = new Uint8Array(ID_LENGTH + introduction_payload.length);
              x$.set(introduction_node);
              x$.set(introduction_payload, ID_LENGTH);
              signature = detoxCrypto['sign'](for_signature, real_public_key, real_keypair['ed25519']['private']);
              y$ = introduction_message = new Uint8Array(introduction_payload.length + SIGNATURE_LENGTH);
              y$.set(signature);
              y$.set(introduction_payload, SIGNATURE_LENGTH);
              introduction_message_encrypted = detoxCrypto['one_way_encrypt'](x25519_public_key, introduction_message);
              function path_confirmation(new_node_id, new_route_id, command, data){
                var ref$, signature, rendezvous_token_received, handshake_message_received;
                if (!(are_arrays_equal(first_node, new_node_id) && are_arrays_equal(route_id, new_route_id) && command === ROUTING_COMMAND_CONNECTED)) {
                  return;
                }
                ref$ = parse_confirm_connection_data(data), signature = ref$[0], rendezvous_token_received = ref$[1], handshake_message_received = ref$[2];
                if (!(are_arrays_equal(rendezvous_token_received, rendezvous_token) && detoxCrypto['verify'](signature, rendezvous_token, target_id))) {
                  return;
                }
                encryptor_instance['put_handshake_message'](handshake_message_received);
                this$._encryptor_instances.set(full_target_id, encryptor_instance);
                clearTimeout(path_confirmation_timeout);
                this$._router['off']('data', path_confirmation);
                this$._register_routing_path(real_public_key, target_id, first_node, route_id);
              }
              this$._router['on']('data', path_confirmation);
              this$._router['send_data'](first_node, route_id, ROUTING_COMMAND_INITIALIZE_CONNECTION, compose_initialize_connection_data(rendezvous_token, introduction_node, target_id, introduction_message_encrypted));
              this$['fire']('connection_progress', real_public_key, target_id, CONNECTION_PROGRESS_INTRODUCTION_SENT);
              path_confirmation_timeout = timeoutSet(CONNECTION_TIMEOUT, function(){
                this$._router['off']('data', path_confirmation);
                encryptor_instance['destroy']();
                try_to_introduce();
              });
            }
            try_to_introduce();
          }
          this$._router['on']('data', found_introduction_nodes);
          this$._router['send_data'](first_node, route_id, ROUTING_COMMAND_FIND_INTRODUCTION_NODES_REQUEST, target_id);
          find_introduction_nodes_timeout = timeoutSet(CONNECTION_TIMEOUT, function(){
            this$._router['off']('data', found_introduction_nodes);
            this$['fire']('connection_failed', real_public_key, target_id, CONNECTION_ERROR_CANT_FIND_INTRODUCTION_NODES);
          });
        })['catch'](function(error){
          error_handler(error);
          this$['fire']('connection_failed', real_public_key, target_id, CONNECTION_ERROR_CANT_CONNECT_TO_RENDEZVOUS_POINT);
        });
        return real_public_key;
      },
      'get_max_data_size': function(){
        return this._max_data_size;
      }
      /**
       * @param {!Uint8Array}	real_public_key	Own real long-term public key as returned by `announce()` and `connect_to()` methods
       * @param {!Uint8Array}	target_id		Should be connected already
       * @param {number}		command			Command from range `0..255`
       * @param {!Uint8Array}	data			Up to 65 KiB (limit defined in `@detox/transport`)
       */,
      'send_to': function(real_public_key, target_id, command, data){
        var full_target_id, encryptor_instance, multiplexer, x$, data_with_header, this$ = this;
        full_target_id = concat_arrays([real_public_key, target_id]);
        encryptor_instance = this._encryptor_instances.get(full_target_id);
        if (!encryptor_instance || data.length > this._max_data_size) {
          return;
        }
        multiplexer = this._multiplexers.get(full_target_id);
        if (!multiplexer) {
          return;
        }
        x$ = data_with_header = new Uint8Array(data.length + 1);
        x$.set([command]);
        x$.set(data, 1);
        multiplexer['feed'](data_with_header);
        if (this._pending_sending.has(full_target_id)) {
          return;
        }
        this._pending_sending.set(full_target_id, setTimeout(function(){
          var data_block, data_block_encrypted;
          this$._pending_sending['delete'](full_target_id);
          while (multiplexer['have_more_blocks']()) {
            data_block = multiplexer['get_block']();
            data_block_encrypted = encryptor_instance['encrypt'](data_block);
            this$._send_to_routing_node(real_public_key, target_id, ROUTING_COMMAND_DATA, data_block_encrypted);
          }
        }));
      },
      'destroy': function(){
        var this$ = this;
        if (this._destroyed) {
          return;
        }
        clearInterval(this._cleanup_interval);
        clearInterval(this._keep_announce_routes_interval);
        clearInterval(this._get_more_nodes_interval);
        this._routing_paths.forEach(function(arg$){
          var node_id, route_id;
          node_id = arg$[0], route_id = arg$[1];
          this$._unregister_routing_path(node_id, route_id);
        });
        this._pending_connection.forEach(function(arg$){
          var connection_timeout;
          connection_timeout = arg$[3];
          clearTimeout(connection_timeout);
        });
        this._dht['destroy']();
        this._router['destroy']();
        this._destroyed = true;
      }
      /**
       * @return {boolean}
       */,
      _more_nodes_needed: function(){
        return !!(this._aware_of_nodes.size < AWARE_OF_NODES_LIMIT || this._get_stale_aware_of_nodes(true).length);
      }
      /**
       * @param {boolean=} early_exit Will return single node if present, used to check if stale nodes are present at all
       *
       * @return {!Array<string>}
       */,
      _get_stale_aware_of_nodes: function(early_exit){
        var stale_aware_of_nodes, stale_older_than, exited;
        early_exit == null && (early_exit = false);
        stale_aware_of_nodes = [];
        stale_older_than = +new Date - STALE_AWARE_OF_NODE_TIMEOUT * 1000;
        exited = false;
        this._aware_of_nodes.forEach(function(date, node_id){
          if (!exited && date < stale_older_than) {
            stale_aware_of_nodes.push(node_id);
            if (early_exit && !exited) {
              exited = true;
            }
          }
        });
        return stale_aware_of_nodes;
      }
      /**
       * Request more nodes to be aware of from some of the nodes already connected to
       */,
      _get_more_nodes: function(){
        var nodes, i$, len$, node_id;
        nodes = this._pick_random_connected_nodes(5);
        if (!nodes) {
          return;
        }
        for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
          node_id = nodes[i$];
          this._get_more_nodes_from(node_id);
        }
      }
      /**
       * @param {!Uint8Array} node_id
       */,
      _get_more_nodes_from: function(node_id){
        this._get_nodes_requested.add(node_id);
        this._send_to_dht_node(node_id, DHT_COMMAND_GET_NODES_REQUEST, new Uint8Array(0));
      }
      /**
       * Get some random nodes suitable for constructing routing path through them or for acting as introduction nodes
       *
       * @param {number}					number_of_nodes
       * @param {!Array<!Uint8Array>=}	exclude_nodes
       *
       * @return {Array<!Uint8Array>} `null` if there was not enough nodes
       */,
      _pick_nodes_for_routing_path: function(number_of_nodes, exclude_nodes){
        var connected_node, intermediate_nodes;
        connected_node = this._pick_random_connected_nodes(1, exclude_nodes);
        if (!connected_node) {
          return null;
        }
        intermediate_nodes = this._pick_random_aware_of_nodes(number_of_nodes - 1, exclude_nodes);
        if (!intermediate_nodes) {
          return null;
        }
        return connected_node.concat(intermediate_nodes);
      }
      /**
       * Get some random nodes from already connected nodes
       *
       * @param {number=}					up_to_number_of_nodes
       * @param {!Array<!Uint8Array>=}	exclude_nodes
       *
       * @return {Array<!Uint8Array>} `null` if there is no nodes to return
       */,
      _pick_random_connected_nodes: function(up_to_number_of_nodes, exclude_nodes){
        var connected_nodes, i$, ref$, len$, bootstrap_node, i, results$ = [];
        up_to_number_of_nodes == null && (up_to_number_of_nodes = 1);
        exclude_nodes == null && (exclude_nodes = []);
        if (!this._connected_nodes.size) {
          this._dht['lookup'](random_bytes(ID_LENGTH));
          return null;
        }
        connected_nodes = Array.from(this._connected_nodes.values());
        for (i$ = 0, len$ = (ref$ = this['get_bootstrap_nodes']()).length; i$ < len$; ++i$) {
          bootstrap_node = ref$[i$];
          exclude_nodes.push(bootstrap_node['node_id']);
        }
        connected_nodes = connected_nodes.filter(function(node){
          return !in$(node, exclude_nodes);
        });
        if (!connected_nodes.length) {
          return null;
        }
        for (i$ = 0; i$ < up_to_number_of_nodes; ++i$) {
          i = i$;
          if (connected_nodes.length) {
            results$.push(pull_random_item_from_array(connected_nodes));
          }
        }
        return results$;
      }
      /**
       * Get some random nodes from those that current node is aware of
       *
       * @param {number}					number_of_nodes
       * @param {!Array<!Uint8Array>=}	exclude_nodes
       *
       * @return {Array<!Uint8Array>} `null` if there was not enough nodes
       */,
      _pick_random_aware_of_nodes: function(number_of_nodes, exclude_nodes){
        var aware_of_nodes, i$, i, results$ = [];
        if (this._aware_of_nodes.size < number_of_nodes) {
          return null;
        }
        aware_of_nodes = Array.from(this._aware_of_nodes.keys());
        if (exclude_nodes) {
          aware_of_nodes = aware_of_nodes.filter(function(node){
            return !in$(node, exclude_nodes);
          });
        }
        if (aware_of_nodes.length < number_of_nodes) {
          return null;
        }
        for (i$ = 0; i$ < number_of_nodes; ++i$) {
          i = i$;
          results$.push(pull_random_item_from_array(aware_of_nodes));
        }
        return results$;
      }
      /**
       * @param {!Uint8Array} real_public_key
       * @param {!Uint8Array} target_id		Last node in routing path, responder
       * @param {!Uint8Array} node_id			First node in routing path, used for routing path identification
       * @param {!Uint8Array} route_id		ID of the route on `node_id`
       */,
      _register_routing_path: function(real_public_key, target_id, node_id, route_id){
        var source_id, full_target_id;
        source_id = concat_arrays([node_id, route_id]);
        if (this._routing_path_to_id.has(source_id)) {
          return;
        }
        full_target_id = concat_arrays([real_public_key, target_id]);
        this._id_to_routing_path.set(full_target_id, [node_id, route_id]);
        this._routing_path_to_id.set(source_id, [real_public_key, target_id]);
        this._multiplexers.set(full_target_id, fixedSizeMultiplexer['Multiplexer'](this._max_data_size, this._max_packet_data_size));
        this._demultiplexers.set(full_target_id, fixedSizeMultiplexer['Demultiplexer'](this._max_data_size, this._max_packet_data_size));
        this['fire']('connected', real_public_key, target_id);
      }
      /**
       * @param {!Uint8Array} node_id		First node in routing path, used for routing path identification
       * @param {!Uint8Array} route_id	ID of the route on `node_id`
       */,
      _unregister_routing_path: function(node_id, route_id){
        var source_id, ref$, real_public_key, target_id, full_target_id, announced_to, encryptor_instance, this$ = this;
        source_id = concat_arrays([node_id, route_id]);
        if (!this._routing_paths.has(source_id)) {
          return;
        }
        this._routing_paths['delete'](source_id);
        this._router['destroy_routing_path'](node_id, route_id);
        this._pending_pings['delete'](source_id);
        this._announcements_from.forEach(function(arg$, target_id){
          var node_id, route_id, announce_interval, source_id_local;
          node_id = arg$[0], route_id = arg$[1], announce_interval = arg$[2];
          source_id_local = concat_arrays([node_id, route_id]);
          if (!are_arrays_equal(source_id, source_id_local)) {
            return;
          }
          clearInterval(announce_interval);
          this$._announcements_from['delete'](target_id);
        });
        if (!this._routing_path_to_id.has(source_id)) {
          return;
        }
        ref$ = this._routing_path_to_id.get(source_id), real_public_key = ref$[0], target_id = ref$[1];
        full_target_id = concat_arrays([real_public_key, target_id]);
        this._routing_path_to_id['delete'](source_id);
        this._id_to_routing_path['delete'](full_target_id);
        if (this._pending_sending.has(full_target_id)) {
          clearTimeout(this._pending_sending.get(full_target_id));
          this._pending_sending['delete'](full_target_id);
        }
        if (this._real_keypairs.has(real_public_key)) {
          announced_to = this._real_keypairs.get(real_public_key)[3];
          announced_to['delete'](target_id);
        }
        encryptor_instance = this._encryptor_instances.get(full_target_id);
        if (encryptor_instance) {
          encryptor_instance['destroy']();
          this._encryptor_instances['delete'](full_target_id);
        }
        this._multiplexers['delete'](full_target_id);
        this._demultiplexers['delete'](full_target_id);
        this['fire']('disconnected', real_public_key, target_id);
      }
      /**
       * @param {!Uint8Array}	node_id
       * @param {number}		command	0..245
       * @param {!Uint8Array}	data
       */,
      _send_to_dht_node: function(node_id, command, data){
        var connected_timeout, this$ = this;
        if (this._connected_nodes.has(node_id)) {
          this._update_connection_timeout(node_id);
          this._dht['send_data'](node_id, command, data);
          return;
        }
        function connected(new_node_id){
          if (!are_arrays_equal(node_id, new_node_id)) {
            return;
          }
          clearTimeout(connected_timeout);
          this$._dht['off']('node_connected', connected);
          this$._update_connection_timeout(node_id);
          this$._dht['send_data'](node_id, command, data);
        }
        this._dht['on']('node_connected', connected);
        connected_timeout = timeoutSet(ROUTING_PATH_SEGMENT_TIMEOUT, function(){
          this$._dht['off']('node_connected', connected);
        });
        this._dht['lookup'](node_id);
      }
      /**
       * @param {!Uint8Array}	real_public_key
       * @param {!Uint8Array}	target_id
       * @param {number}		command			0..245
       * @param {!Uint8Array}	data
       */,
      _send_to_routing_node: function(real_public_key, target_id, command, data){
        var full_target_id, ref$, node_id, route_id;
        full_target_id = concat_arrays([real_public_key, target_id]);
        if (!this._id_to_routing_path.has(full_target_id)) {
          return;
        }
        ref$ = this._id_to_routing_path.get(full_target_id), node_id = ref$[0], route_id = ref$[1];
        this._router['send_data'](node_id, route_id, command, data);
      }
      /**
       * @param {!Uint8Array} node_id
       * @param {!Uint8Array} route_id
       *
       * @return {boolean} `true` if ping was sent (not necessary delivered)
       */,
      _send_ping: function(node_id, route_id){
        var source_id;
        source_id = concat_arrays([node_id, route_id]);
        if (this._pending_pings.has(source_id) || !this._routing_paths.has(source_id)) {
          return false;
        }
        this._router['send_data'](node_id, route_id, ROUTING_COMMAND_PING, new Uint8Array(0));
        return true;
      }
      /**
       * @param {!Uint8Array} node_id
       */,
      _update_connection_timeout: function(node_id){
        if (!this._connections_timeouts.has(node_id)) {
          this._add_used_tag(node_id);
        }
        this._connections_timeouts.set(node_id, +new Date);
      }
      /**
       * @param {!Uint8Array} node_id
       */,
      _add_used_tag: function(node_id){
        var value;
        value = this._used_tags.get(node_id) || 0;
        ++value;
        this._used_tags.set(node_id, value);
        if (value === 1) {
          this._dht['add_used_tag'](node_id);
        }
      }
      /**
       * @param {!Uint8Array} node_id
       */,
      _del_used_tag: function(node_id){
        var value;
        value = this._used_tags.get(node_id);
        if (!value) {
          return;
        }
        --value;
        if (!value) {
          this._used_tags['delete'](node_id);
          this._dht['del_used_tag'](node_id);
        } else {
          this._used_tags.set(node_id, value);
        }
      }
    };
    Core.prototype = Object.assign(Object.create(asyncEventer.prototype), Core.prototype);
    Object.defineProperty(Core.prototype, 'constructor', {
      enumerable: false,
      value: Core
    });
    return {
      'ready': function(callback){
        var wait_for;
        wait_for = 2;
        function ready(){
          --wait_for;
          if (!wait_for) {
            callback();
          }
        }
        detoxCrypto['ready'](ready);
        detoxTransport['ready'](ready);
      }
      /**
       * Generate random seed that can be used as keypair seed
       *
       * @return {!Uint8Array} 32 bytes
       */,
      'generate_seed': function(){
        return detoxCrypto['create_keypair']()['seed'];
      },
      'Core': Core
    };
  }
  if (typeof define === 'function' && define['amd']) {
    define(['@detox/crypto', '@detox/transport', '@detox/utils', 'fixed-size-multiplexer', 'async-eventer'], Wrapper);
  } else if (typeof exports === 'object') {
    module.exports = Wrapper(require('@detox/crypto'), require('@detox/transport'), require('@detox/utils'), require('fixed-size-multiplexer'), require('async-eventer'));
  } else {
    this['detox_core'] = Wrapper(this['detox_crypto'], this['detox_transport'], this['detox_utils'], this['fixed_size_multiplexer'], this['async_eventer']);
  }
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);
